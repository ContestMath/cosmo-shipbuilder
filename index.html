<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Placement</title>
    <style>
        canvas {
            border: 1px solid #000;
        }

        #previewSprite {
            position: absolute;
            opacity: 0.7;
            pointer-events: none;
            /* Allow interaction with canvas below */
        }
    </style>
</head>

<body>
    <canvas id="spriteCanvas" width="64" height="64"></canvas>
    <textarea id="jsonInput"></textarea>
    <button id="loadButton">Load JSON</button>
    <label for="spriteSelect">Select a Sprite:</label>
    <select id="spriteSelect"></select>
    <button id="exportButton">Export json</button>
    <textarea name="json_export" id="json_export" disabled width="200" height="200"></textarea>


    <script>
        const spriteData = {
            "cosmoteer.corridor": { "mass": 1, "size": [1, 1] },
            "cosmoteer.structure": { "mass": 0.33, "size": [1, 1] },
            "cosmoteer.structure_wedge": { "mass": 0.17, "size": [1, 1] },
            "cosmoteer.structure_1x2_wedge": { "mass": 0.33, "size": [1, 2] },
            "cosmoteer.structure_1x3_wedge": { "mass": 0.5, "size": [1, 3] },
            "cosmoteer.structure_tri": { "mass": 0.08, "size": [1, 1] },
            "cosmoteer.laser_blaster_small": { "mass": 2.5, "size": [1, 2], "sprite_size": [1, 4] },
            "cosmoteer.laser_blaster_large": { "mass": 7.68, "size": [2, 3], "sprite_size": [2, 6] },
            "cosmoteer.disruptor": { "mass": 3.48, "size": [1, 3], "sprite_size": [1, 5] },
            "cosmoteer.ion_beam_emitter": { "mass": 8, "size": [2, 4], "sprite_size": [2, 5] },
            "cosmoteer.resource_collector": { "mass": 4, "size": [2, 2] },
            "cosmoteer.ion_beam_prism": { "mass": 7.7, "size": [2, 2], "sprite_size": [2, 2.5] },
            "cosmoteer.tractor_beam_emitter": { "mass": 32.07, "size": [5, 5] },
            "cosmoteer.point_defense": { "mass": 1, "size": [1, 1], "sprite_size": [1, 2] },
            "cosmoteer.mining_laser_small": { "mass": 7.4, "size": [2, 3] },
            "cosmoteer.cannon_med": { "mass": 4.44, "size": [2, 1], "sprite_size": [2, 3] },
            "cosmoteer.sensor_array": { "mass": 11.54, "size": [3, 3] },
            "cosmoteer.cannon_large": { "mass": 12.29, "size": [3, 2], "sprite_size": [3, 5] },
            "cosmoteer.hyperdrive_beacon": { "mass": 17.13, "size": [4, 4] },
            "cosmoteer.cannon_deck": { "mass": 27.07, "size": [4, 5], "sprite_size": [4, 7] },
            "cosmoteer.explosive_charge": { "mass": 1, "size": [1, 1] },
            "cosmoteer.roof_light": { "mass": 1, "size": [1, 1] },
            "cosmoteer.missile_launcher": { "mass": 8, "size": [2, 3], "sprite_size": [2, 4] },
            "cosmoteer.roof_headlight": { "mass": 1, "size": [1, 1] },
            "cosmoteer.railgun_loader": { "mass": 24, "size": [2, 3] },
            "cosmoteer.armor_structure_hybrid_1x1": { "mass": 1.5, "size": [1, 1] },
            "cosmoteer.armor_structure_hybrid_1x2": { "mass": 3, "size": [1, 2] },
            "cosmoteer.railgun_accelerator": { "mass": 36, "size": [2, 3] },
            "cosmoteer.armor_structure_hybrid_1x3": { "mass": 4.5, "size": [1, 3] },
            "cosmoteer.armor_structure_hybrid_tri": { "mass": 1, "size": [1, 1] },
            "cosmoteer.railgun_launcher": { "mass": 36, "size": [2, 3], "sprite_size": [2, 4] },
            "cosmoteer.armor": { "mass": 3, "size": [1, 1] },
            "cosmoteer.armor_2x1": { "mass": 6, "size": [2, 1] },
            "cosmoteer.flak_cannon_large": { "mass": 16.77, "size": [3, 6], "sprite_size": [3, 8] },
            "cosmoteer.armor_wedge": { "mass": 1.5, "size": [1, 1] },
            "cosmoteer.armor_1x2_wedge": { "mass": 3, "size": [1, 2] },
            "cosmoteer.shield_gen_small": { "mass": 6, "size": [2, 2], "sprite_size": [2, 3] },
            "cosmoteer.armor_1x3_wedge": { "mass": 4.5, "size": [1, 3] },
            "cosmoteer.armor_tri": { "mass": 0.75, "size": [1, 1] },
            "cosmoteer.shield_gen_large": { "mass": 12.65, "size": [3, 6] },
            "cosmoteer.thruster_small": { "mass": 1.3, "size": [1, 1], "sprite_size": [1, 2] },
            "cosmoteer.thruster_med": { "mass": 2.45, "size": [1, 2], "sprite_size": [1, 3] },
            "cosmoteer.thruster_large": { "mass": 4.99, "size": [2, 2], "sprite_size": [2, 3] },
            "cosmoteer.thruster_boost": { "mass": 8.88, "size": [2, 3], "sprite_size": [2, 5] },
            "cosmoteer.fire_extinguisher": { "mass": 1, "size": [1, 1] },
            "cosmoteer.thruster_huge": { "mass": 11, "size": [3, 3], "sprite_size": [3, 5] },
            "cosmoteer.control_room_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.control_room_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.thruster_small_2way": { "mass": 1.61, "size": [1, 1], "sprite_size": [2, 2] },
            "cosmoteer.control_room_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.thruster_small_3way": { "mass": 1.91, "size": [1, 1], "sprite_size": [3, 2] },
            "cosmoteer.hyperdrive_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.engine_room": { "mass": 9, "size": [3, 3] },
            "cosmoteer.crew_quarters_small": { "mass": 2, "size": [1, 2] },
            "cosmoteer.crew_quarters_med": { "mass": 4, "size": [2, 2] },
            "cosmoteer.airlock": { "mass": 1, "size": [1, 1] },
            "cosmoteer.conveyor": { "mass": 1, "size": [1, 1] },
            "cosmoteer.reactor_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.reactor_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.reactor_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.power_storage": { "mass": 4, "size": [2, 2] },
            "cosmoteer.factory_ammo": { "mass": 4, "size": [2, 2] },
            "cosmoteer.factory_he": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_emp": { "mass": 12, "size": [3, 4] },
            "cosmoteer.factory_nuke": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_mine": { "mass": 12, "size": [4, 3] },
            "cosmoteer.factory_steel": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_coil": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_coil2": { "mass": 12, "size": [4, 3] },
            "cosmoteer.factory_tristeel": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_diamond": { "mass": 6, "size": [2, 3] },
            "cosmoteer.factory_processor": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_uranium": { "mass": 12, "size": [3, 4] },
            "cosmoteer.storage_2x2": { "mass": 4, "size": [2, 2] },
            "cosmoteer.storage_3x2": { "mass": 6, "size": [3, 2] },
            "cosmoteer.storage_3x3": { "mass": 9, "size": [3, 3] },
            "cosmoteer.storage_4x3": { "mass": 12, "size": [4, 3] },
            "cosmoteer.storage_4x4": { "mass": 16, "size": [4, 4] },
            "cosmoteer.chaingun": { "mass": 17.77, "size": [3, 5], "sprite_size": [3, 7] },
            "cosmoteer.chaingun_magazine": { "mass": 2, "size": [1, 2] },
            "cosmoteer.hyperdrive_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.thruster_rocket_battery": { "mass": 2, "size": [1, 2] },
            "cosmoteer.thruster_rocket_extender": { "mass": 6, "size": [3, 2] },
            "cosmoteer.thruster_rocket_nozzle": { "mass": 14.4, "size": [3, 4], "sprite_size": [3, 5] },
            "cosmoteer.hyperdrive_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.manipulator_beam_emitter": { "mass": 4, "size": [2, 2] },
            "cosmoteer.crew_quarters_large": { "mass": 12, "size": [3, 4] }
        };

        // parts with special attributes
        const upTurrets = [
            "cosmoteer.laser_blaster_small",
            "cosmoteer.laser_blaster_large",
            "cosmoteer.disruptor",
            "cosmoteer.ion_beam_emitter",
            "cosmoteer.ion_beam_prism",
            "cosmoteer.point_defense",
            "cosmoteer.cannon_med",
            "cosmoteer.cannon_large",
            "cosmoteer.cannon_deck",
            "cosmoteer.missile_launcher",
            "cosmoteer.railgun_launcher",
            "cosmoteer.flak_cannon_large",
            "cosmoteer.shield_gen_small",
            "cosmoteer.chaingun",
        ]

        const downTurrets = [
            "cosmoteer.thruster_small",
            "cosmoteer.thruster_med",
            "cosmoteer.thruster_large",
            "cosmoteer.thruster_huge",
            "cosmoteer.thruster_boost",
        ]

        const multiple_turrets = ["cosmoteer.thruster_small_2way", "cosmoteer.thruster_small_3way"]

        const json_import_text = document.getElementById('jsonInput');
        const load_json_button = document.getElementById('loadButton');
        const export_json_button = document.getElementById('exportButton');
        // add event listener to export json button
        export_json_button.addEventListener('click', export_json);
        load_json_button.addEventListener('click', loadJson);
        const canvas = document.getElementById('spriteCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 64; // Size of each grid cell
        let sprites = [];
        let doors = []
        let resources = []
        let minX = 0, minY = 0, maxX = 0, maxY = 0; // adjust canvas size
        let shipdata = {};


        function export_json() {
            // get shipdata, update shipdata.parts with sprites then export
            // drop "width" and "height" from sprite data
            new_parts = []
            sprites.forEach((sprite) => {
                delete sprite.width;
                delete sprite.height;
                new_parts.push(sprite)
            })

            shipdata.Parts = new_parts
            shipdata.Doors = doors;
            shipdata.NewFlexResourceGridTypes = resources;

            console.log(shipdata)
            // convert shipdata to json
            const json = JSON.stringify(shipdata);
            console.log(json);
            // clear textarea
            document.getElementById("json_export").value = "";
            // fill textarea id="json_export" with json string
            document.getElementById("json_export").value = json;
        }

        // Function to draw the grid
        function drawGrid() {
            ctx.strokeStyle = '#ccc';
            ctx.font = '12px Arial';
            ctx.fillStyle = '#000';

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    const xPos = (x - minX) * gridSize;
                    const yPos = (y - minY) * gridSize;
                    ctx.strokeRect(xPos, yPos, gridSize, gridSize);

                    // Draw coordinates
                    ctx.fillText(`(${x},${y})`, xPos + 2, yPos + 12);
                }
            }
        }

        function loadJson() {
            // Clear the sprite data
            sprites = [];
            doors = [];
            resources = [];

            const json = json_import_text.value;
            console.log(json);
            const data = JSON.parse(json);
            const part_data = data.Parts|| [];
            const doordata = Array.isArray(data.Doors) ? data.Doors : [];
            const resource_data = Array.isArray(data.NewFlexResourceGridTypes) ? data.NewFlexResourceGridTypes : [];

            // Calculate the min and max positions
            minX = Infinity;
            minY = Infinity;
            maxX = -Infinity;
            maxY = -Infinity;

            part_data.forEach(sprite => {
                const [x, y] = sprite.Location;
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                sprites.push(sprite);
            });

            doordata.forEach(door => {
                doors.push(door)
            });

            resource_data.forEach(resource => {
                resources.push(resource)
            });

            // Extend the grid by 10 squares in each direction
            minX -= 10;
            minY -= 10;
            maxX += 10;
            maxY += 10;

            // Adjust canvas size
            const width = (maxX - minX + 1) * gridSize;
            const height = (maxY - minY + 1) * gridSize;
            canvas.width = width;
            canvas.height = height;

            redrawCanvas();
        }

        function sprite_position(part, position) {
            const sprite_size = spriteData[part["ID"]].sprite_size || spriteData[part["ID"]].size;
            const part_size = spriteData[part["ID"]].size;
            const part_rotation = part["Rotation"];

            if (part_rotation == 0 && upTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 3 && upTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 1 && downTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 2 && downTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (multiple_turrets.includes(part["ID"])) {
                if (part["ID"] == "cosmoteer.thruster_small_2way") {
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                    if (part_rotation == 2) {
                        position[0] -= 1;
                        position[1] -= 1;
                    }
                    if (part_rotation == 3) {
                        position[1] -= 1;
                    }
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                } else if (part["ID"] == "cosmoteer.thruster_small_3way") {
                    if (part_rotation == 2) {
                        if (part_rotation == 3) {
                            position[1] -= 1;
                        }
                    }
                }
            }
            if (part["ID"] == "cosmoteer.missile_launcher" && getPartData(part).get("missile_type") != 0) {

                if (part_rotation == 0) {
                    position[1] -= 1;
                }
                if (part_rotation == 3) {
                    position[0] -= 1;
                }
            }
            return position;
        }

        function rotate_img(image, angle, flipx) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions based on the rotation
            if (angle % 2 === 0) {
                canvas.width = image.width;
                canvas.height = image.height;
            } else {
                canvas.width = image.height;
                canvas.height = image.width;
            }

            // Translate to center and rotate
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(angle * Math.PI / 2);

            if (flipx) {
                ctx.scale(-1, 1);
            }

            ctx.drawImage(image, -image.width / 2, -image.height / 2);

            return canvas;
        }

        function get_all_locations() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts

            let locations = []
            let width;
            let height;

            part_data.forEach(sprite => {
                const sprite_size = spriteData[sprite["ID"]].sprite_size || spriteData[sprite["ID"]].size;

                if (sprite.Rotation % 2 == 0) {
                    width = sprite_size[0];
                    height = sprite_size[1];
                } else {
                    width = sprite_size[1];
                    height = sprite_size[0];
                }

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        locations.push([sprite.Location[0] + i, sprite.Location[1] + j]);
                    }
                } 

                locations.push(sprite.Location)
            });
            return locations;
        }

        function draw_resources() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts

            get_all_locations().forEach(location => {
                resources.forEach(resource => {
                    if (location[0] == resource.Key[0] && location[1] == resource.Key[1]) {
                        const imageName = resource.Value;
                        const img = new Image();

                        img.src = `sprites/${imageName}.png`;

                        img.onload = () => {
                            x = location[0];
                            y = location[1];
                            const rotatedImage = rotate_img(img, 0, false);
                            ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        };
                    }
                })
            })
        }

        function draw_doors() {
            console.log(doors)
            doors.forEach(door => {
                    const img = new Image();

                    img.src = `sprites/door.png`;
                    console.log("door")
                    img.onload = () => {
                        console.log("loaded")
                        x = door.Cell[0];
                        y = door.Cell[1];
                        let angle = 0
                        if (door.Orientation==0) {
                            y -= 0.5
                            angle = 1
                        } else {
                            x -= 0.5 
                        }
                        const rotatedImage = rotate_img(img, angle, false);
                        ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    };
                })
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            drawGrid(); // Redraw the grid

            sprites.forEach(sprite => {
                const imageName = sprite["ID"].replace("cosmoteer.", "");
                const img = new Image();

                const partData = getPartData(sprite);
                const missileType = partData.get("missile_type");

                if (missileType === 2) {
                    img.src = `sprites/nuke_launcher.png`;
                } else if (missileType === 1) {
                    img.src = `sprites/emp_launcher.png`;
                } else if (missileType === 3) {
                    img.src = `sprites/mine_launcher.png`;
                } else {
                    img.src = `sprites/${imageName}.png`;
                }

                img.onload = () => {
                    let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                    const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                    ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    sprite.width = rotatedImage.width;
                    sprite.height = rotatedImage.height;
                    square_map(sprite);
                };
            });
            draw_doors();
            draw_resources();
        }

        let gridMap = {}; // To store the grid map

        function square_map(sprite) {
            const [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
            const width = Math.ceil(sprite.width / gridSize);
            const height = Math.ceil(sprite.height / gridSize);

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const squareX = x + i;
                    const squareY = y + j;
                    const key = `${squareX},${squareY}`;

                    gridMap[key] = {
                        square_x: squareX,
                        square_y: squareY,
                        is_drawn_by_sprite: sprite
                    };
                }
            }
        }

        //Get interesting data from a part
        function getPartData(part) {
            let part_data = new Map()
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const partUIToggleStates = data.PartUIToggleStates || [];

            // if "PartUIToggleStates": "Unset", then skip
            if (partUIToggleStates === "Unset") {
                return part_data
            }
            for (const entry of partUIToggleStates) {
                const key = entry.Key || {};


                if (part.Location[0] == key[0].Location[0] && part.Location[1] == key[0].Location[1]) {

                    // Power toggle (1 is on 0 is off)
                    if (key.includes("on_off")) {
                        part_data.set("on_off", entry.Value);
                    }

                    //fire mode (hold fire:2^32-1, fire at target: 1, fire at will: 0, autofire: 2)
                    if (key.includes("fire_mode")) {
                        part_data.set("fire_mode", entry.Value);
                    }

                    //missile type (3 is mine, 1 is emp, 2 is nuke, 0 is he)
                    if (key.includes("missile_type")) {
                        part_data.set("missile_type", entry.Value);
                    }
                }

            }

            return part_data

        }


        // Create preview sprite
        const previewSprite = document.createElement('img');
        previewSprite.id = 'previewSprite';
        document.body.appendChild(previewSprite);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        // add sprite to canvas when clicked
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('contextmenu', handleRightClick); // Listen for right-click

        let deleteMode = false;
        let rotation = 0; // Initial rotation (0 degrees)
        let lastX = 0;
        let lastY = 0;
        let lastRotation = 0;
        let lastDrawX = 0;
        let lastDrawY = 0;
        let lastWidth = 0;
        let lastHeight = 0;

        const previewSpriteImage = new Image();
        let isPreviewSpriteLoaded = false;


        // Function to load the selected sprite image
        function loadPreviewSpriteImage() {
            const selectedSprite = document.getElementById('spriteSelect').value;
            const imageName = selectedSprite.replace("cosmoteer.", "");
            previewSpriteImage.src = `sprites/${imageName}.png`;

            previewSpriteImage.onload = () => {
                isPreviewSpriteLoaded = true;
            };
        }

        // Call the function to load the initial preview sprite
        loadPreviewSpriteImage();

        let affectedSquares = [];

        function handleCanvasMouseMove(event) {
            if (!isPreviewSpriteLoaded) return;

            const x = event.offsetX;
            const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize) * gridSize;
            const mouseY = Math.floor(y / gridSize) * gridSize;
            const canvasPositionX = (mouseX / gridSize) + minX;
            const canvasPositionY = (mouseY / gridSize) + minY;

            if (lastX === canvasPositionX && lastY === canvasPositionY && lastRotation === rotation) {
                return;
            }

            const spriteDataPreview = {
                FlipX: false,
                ID: document.getElementById('spriteSelect').value,
                Location: [canvasPositionX, canvasPositionY],
                Rotation: rotation
            };

            let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
            const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);

            // Clear the previous preview sprite and redraw affected sprites
            clearPreview();

            // Draw the new preview sprite
            drawPreview(spriteDataPreview, (drawX - minX) * gridSize + 1, (drawY - minY) * gridSize + 1, rotatedImage);

            // Update last known position and dimensions
            lastX = canvasPositionX;
            lastY = canvasPositionY;
            lastRotation = rotation;
            lastDrawX = (drawX - minX) * gridSize + 1;
            lastDrawY = (drawY - minY) * gridSize + 1;
            lastWidth = rotatedImage.width - 2;
            lastHeight = rotatedImage.height - 2;

            // Store affected grid squares
            affectedSquares = [];
            const width = Math.ceil(rotatedImage.width / gridSize);
            const height = Math.ceil(rotatedImage.height / gridSize);

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const squareX = canvasPositionX + i;
                    const squareY = canvasPositionY + j;
                    const key = `${squareX},${squareY}`;
                    affectedSquares.push(key);
                }
            }
        }


        function clearPreview() {
            ctx.clearRect(lastDrawX, lastDrawY, lastWidth, lastHeight);

            // Redraw the sprites that were overwritten by the preview sprite
            affectedSquares.forEach(key => {
                if (gridMap[key]) {
                    const sprite = gridMap[key].is_drawn_by_sprite;
                    const imageName = sprite["ID"].replace("cosmoteer.", "");
                    const img = new Image();

                    const partData = getPartData(sprite);
                    const missileType = partData.get("missile_type");

                    if (missileType === 2) {
                        img.src = `sprites/nuke_launcher.png`;
                    } else if (missileType === 1) {
                        img.src = `sprites/emp_launcher.png`;
                    } else if (missileType === 3) {
                        img.src = `sprites/mine_launcher.png`;
                    } else {
                        img.src = `sprites/${imageName}.png`;
                    }

                    img.onload = () => {
                        let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                        const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                        ctx.clearRect((x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    };
                }
            });
        }


        // Function to draw the preview sprite
        function drawPreview(spriteDataPreview, drawX, drawY, rotatedImage) {
            ctx.globalAlpha = 0.5;
            ctx.drawImage(rotatedImage, drawX, drawY, rotatedImage.width - 2, rotatedImage.height - 2);
            ctx.globalAlpha = 1.0;
        }

        // Function to handle sprite selection change
        function handleSpriteSelectionChange() {
            loadPreviewSpriteImage();
        }

        // Attach the mousemove event listener to the canvas
        canvas.addEventListener('mousemove', handleCanvasMouseMove);

        // Attach the sprite selection change event listener
        document.getElementById('spriteSelect').addEventListener('change', handleSpriteSelectionChange);


        // Function to handle canvas click to place the sprite
        function handleCanvasClick(event) {
            const selectedSprite = document.getElementById('spriteSelect').value;
            const x = event.offsetX;
            const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize);
            const mouseY = Math.floor(y / gridSize);
            const canvas_position_x = Math.floor(mouseX - maxX + 1)
            const canvas_position_y = Math.floor(mouseY - maxY + 1)
            console.log("mouseX", mouseX, "mouseY", mouseY);
            console.log("canvas_position_x", canvas_position_x, "canvas_position_y", canvas_position_y);
            const spriteDataEntry = {
                FlipX: false,
                ID: selectedSprite,
                Location: [canvas_position_x, canvas_position_y],
                Rotation: rotation
            };
            console.log(spriteDataEntry);
            sprites.push(spriteDataEntry);
            console.log(sprites);
            redrawCanvas();
        }

        // Function to handle right-click to change rotation
        function handleRightClick(event) {
            event.preventDefault();
            rotation = (rotation + 1) % 4;
            handleCanvasMouseMove(event); // Update the preview with new rotation
        }


        function clearPreviewSprite() {
            previewSprite.style.display = 'none'; // Hide the preview sprite
        }
        function unclearPreviewSprite() {
            previewSprite.style.display = 'block'; // Hide the preview sprite
        }

        // Populate the sprite select dropdown with sprite names
        const spriteSelect = document.getElementById('spriteSelect');
        for (const spriteName in spriteData) {
            const option = document.createElement('option');
            option.value = spriteName;
            option.textContent = spriteName;
            spriteSelect.appendChild(option);
        }

        // Initialize the grid
        drawGrid();
    </script>
</body>

</html>