<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Placement</title>
    <style>
        canvas {
            border: 1px solid #000;
        }

        #previewSprite {
            position: absolute;
            opacity: 0.7;
            pointer-events: none;
            /* Allow interaction with canvas below */
        }
    </style>
</head>

<body>
    <div style="
    display: flex;
    width: 90%;
    flex-direction: row;
    align-content: flex-start;
    justify-content: flex-start;
    align-items: flex-start;
">
        <div style="
    width: 20%;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: stretch;
">
            <fieldset>
                <legend>Load a ship</legend>
                <div>
                    <textarea name="b64_input" id="b64_input"></textarea>
                    <button id="load_b64">Load from URL</button>
                </div>
                <div>
                    <textarea id="jsonInput"></textarea>
                    <button id="loadButton">Load JSON</button>
                </div>
            </fieldset>

            <fieldset>
                <legend>Select a mode:</legend>
                <div>
                    <input type="radio" id="Place" name="cursor_mode" value="Place" checked />
                    <label for="Place">Place</label>
                </div>
                <div>
                    <input type="radio" id="Select" name="cursor_mode" value="Select" />
                    <label for="Select">Select</label>
                </div>
                <div>
                    <input type="radio" id="Delete" name="cursor_mode" value="Delete" />
                    <label for="Delete">Delete</label>
                </div>
                <div>
                    <input type="radio" id="Move" name="cursor_mode" value="Move" />
                    <label for="Move">Move</label>
                </div>
                <div>
                    <label id="coord_on_canvas"></label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Parts</legend>
                <div>
                    <label for="spriteSelect">Select a Sprite:</label>
                    <select id="spriteSelect"></select>
                </div>
                <div>
                    <label id="selected_parts">Selected Part(s):</label>
                    <select id="propertySelect"></select>
                </div>
                <div>
                    <textarea id="propertyEdit"></textarea>
                    <button id="applyPropertyButton">Apply</button>
                </div>
            </fieldset>

            <fieldset>
                <legend>Ship config</legend>
                <div>
                    <select id="shipPropertySelect"></select>
                    <textarea id="shipPropertyEdit"></textarea>
                    <button id="applyShipPropertyButton">Apply</button>
                </div>
            </fieldset>

            <fieldset>
                <legend>Stats</legend>
                <div>
                    <label id="shipStatsLabel">Ship Stats: </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Export Ship</legend>
                <div>
                    <button id="exportButton">Export json</button>
                    <textarea name="json_export" id="json_export" disabled width="200" height="200"></textarea>
                </div>
                <div>
                    <a href="" id="ship_link" style="display: none">Generated Ship, click here</a>
                    <button id="post_json">Generate Ship File</button>
                </div>
            </fieldset>
        </div>
        <div style="
        width: 80%;
        display: flex;
        flex-direction: column;
    ">
            <canvas id="spriteCanvas" width="64" height="64"></canvas>
        </div>
    </div>
    <script>
        const spriteData = {
            "cosmoteer.corridor": { "mass": 1, "size": [1, 1], "cost": 0.1, "category": "" },
            "cosmoteer.door": { "size": [1, 1], "cost": 0.1, "category": "" },
            "cosmoteer.delete": { "mass": 1, "size": [1, 1] },
            "cosmoteer.structure": { "mass": 0.33, "size": [1, 1], "cost": 0.05, "category": "" },
            "cosmoteer.structure_wedge": { "mass": 0.17, "size": [1, 1], "cost": 0.025, "category": "" },
            "cosmoteer.structure_1x2_wedge": { "mass": 0.33, "size": [1, 2], "cost": 0.05, "category": "" },
            "cosmoteer.structure_1x3_wedge": { "mass": 0.5, "size": [1, 3], "cost": 0.075, "category": "" },
            "cosmoteer.structure_tri": { "mass": 0.08, "size": [1, 1], "cost": 0.025, "category": "" },
            "cosmoteer.laser_blaster_small": { "mass": 2.5, "size": [1, 2], "sprite_size": [1, 4], "dps": 667, "burst_damage": 500, "cost": 2, "category": "weapon", "cp_cost": 2 },
            "cosmoteer.laser_blaster_large": { "mass": 7.68, "size": [2, 3], "sprite_size": [2, 6], "dps": 1778, "burst_damage": 1000, "cost": 6, "category": "weapon", "cp_cost": 4 },
            "cosmoteer.disruptor": { "mass": 3.48, "size": [1, 3], "sprite_size": [1, 5], "dps": 100, "burst_damage": 200, "cost": 3, "category": "weapon", "cp_cost": 2 },
            "cosmoteer.ion_beam_emitter": { "mass": 8, "size": [2, 4], "sprite_size": [2, 5], "dps": 2500, "burst_damage": 0, "cost": 10, "category": "weapon", "cp_cost": 4 },
            "cosmoteer.resource_collector": { "mass": 4, "size": [2, 2], "cost": 0, "category": "", "cp_cost": 4 },
            "cosmoteer.ion_beam_prism": { "mass": 7.7, "size": [2, 2], "sprite_size": [2, 2.5], "cost": 5, "category": "", "cp_cost": 2 },
            "cosmoteer.tractor_beam_emitter": { "mass": 32.07, "size": [5, 5], "cost": 40, "category": "", "cp_cost": 8 },
            "cosmoteer.point_defense": { "mass": 1, "size": [1, 1], "sprite_size": [1, 2], "dps": 525, "burst_damage": 35, "cost": 1, "category": "weapon", "cp_cost": 1 },
            "cosmoteer.mining_laser_small": { "mass": 7.4, "size": [2, 3], "dps": 1200, "burst_damage": 0, "cost": 6, "category": "weapon", "cp_cost": 3 },
            "cosmoteer.cannon_med": { "mass": 4.44, "size": [2, 1], "sprite_size": [2, 3], "dps": 1000, "burst_damage": 750, "cost": 2, "category": "weapon", "cp_cost": 2 },
            "cosmoteer.sensor_array": { "mass": 11.54, "size": [3, 3], "cost": 20, "category": "", "cp_cost": 8 },
            "cosmoteer.cannon_large": { "mass": 12.29, "size": [3, 2], "sprite_size": [3, 5], "dps": 2000, "burst_damage": 2400, "cost": 5, "category": "weapon", "cost": 0, "category": "", "cp_cost": 4 },
            "cosmoteer.hyperdrive_beacon": { "mass": 17.13, "size": [4, 4], "cost": 40, "category": "", "cp_cost": 12 },
            "cosmoteer.cannon_deck": { "mass": 27.07, "size": [4, 5], "sprite_size": [4, 7], "dps": 6000, "burst_damage": 7500, "cost": 20, "category": "weapon", "cp_cost": 8 },
            "cosmoteer.explosive_charge": { "mass": 1, "size": [1, 1], "cost": 0.6, "category": "" },
            "cosmoteer.roof_light": { "mass": 1, "size": [1, 1], "cost": 0.2, "category": "" },
            "cosmoteer.missile_launcher": { "mass": 8, "size": [2, 3], "sprite_size": [2, 4], "dps": 0, "burst_damage": 0, "cost": 10, "category": "", "cp_cost": 5 },
            "cosmoteer.roof_headlight": { "mass": 1, "size": [1, 1], "cost": 0.3, "category": "" },
            "cosmoteer.railgun_loader": { "mass": 24, "size": [2, 3], "cost": 12.5, "category": "", "cp_cost": 4 },
            "cosmoteer.armor_structure_hybrid_1x1": { "mass": 1.5, "size": [1, 1], "cost": 0.125, "category": "" },
            "cosmoteer.armor_structure_hybrid_1x2": { "mass": 3, "size": [1, 2], "cost": 0.25, "category": "" },
            "cosmoteer.railgun_accelerator": { "mass": 36, "size": [2, 3], "cost": 7.5, "category": "", "cp_cost": 1 },
            "cosmoteer.armor_structure_hybrid_1x3": { "mass": 4.5, "size": [1, 3], "cost": 0.375, "category": "" },
            "cosmoteer.armor_structure_hybrid_tri": { "mass": 1, "size": [1, 1], "cost": 0.075, "category": "" },
            "cosmoteer.railgun_launcher": { "mass": 36, "size": [2, 3], "sprite_size": [2, 4], "dps": 10000, "burst_damage": 2500, "cost": 7.5, "category": "weapon", "cp_cost": 1 },
            "cosmoteer.armor": { "mass": 3, "size": [1, 1], "cost": 0.2, "category": "" },
            "cosmoteer.armor_2x1": { "mass": 6, "size": [2, 1], "cost": 0.4, "category": "" },
            "cosmoteer.flak_cannon_large": { "mass": 16.77, "size": [3, 6], "sprite_size": [3, 8], "dps": 9, "burst_damage": 2250, "cost": 21, "category": "weapon", "cp_cost": 6 },
            "cosmoteer.armor_wedge": { "mass": 1.5, "size": [1, 1], "cost": 0.1, "category": "" },
            "cosmoteer.armor_1x2_wedge": { "mass": 3, "size": [1, 2], "cost": 0.2, "category": "" },
            "cosmoteer.shield_gen_small": { "mass": 6, "size": [2, 2], "sprite_size": [2, 3], "cost": 5, "category": "", "cp_cost": 3 },
            "cosmoteer.armor_1x3_wedge": { "mass": 4.5, "size": [1, 3], "cost": 0.3, "category": "" },
            "cosmoteer.armor_tri": { "mass": 0.75, "size": [1, 1], "cost": 0.05, "category": "" },
            "cosmoteer.shield_gen_large": { "mass": 12.65, "size": [3, 6], "cost": 20, "category": "", "cp_cost": 6 },
            "cosmoteer.thruster_small": { "mass": 1.3, "size": [1, 1], "sprite_size": [1, 2], "cost": 0.5, "category": "thruster", "cp_cost": 1, "thrust": [0, 0, 0.4, 0] },
            "cosmoteer.thruster_med": { "mass": 2.45, "size": [1, 2], "sprite_size": [1, 3], "cost": 1.5, "category": "thruster", "cp_cost": 2, "thrust": [0, 0, 1.2, 0] },
            "cosmoteer.thruster_large": { "mass": 4.99, "size": [2, 2], "sprite_size": [2, 3], "cost": 4, "category": "thruster", "cp_cost": 4, "thrust": [0, 0, 3.2, 0] },
            "cosmoteer.thruster_boost": { "mass": 8.88, "size": [2, 3], "sprite_size": [2, 5], "cost": 6, "category": "thruster", "cp_cost": 6, "thrust": [0, 0, 3.2, 0] },
            "cosmoteer.fire_extinguisher": { "mass": 1, "size": [1, 1], "cost": 0.3, "category": "" },
            "cosmoteer.thruster_huge": { "mass": 11, "size": [3, 3], "sprite_size": [3, 5], "cost": 10, "category": "thruster", "cp_cost": 8, "thrust": [0, 0, 8, 0] },
            "cosmoteer.control_room_small": { "mass": 4, "size": [2, 2], "cost": 10, "category": "", "cp_cost": 0 },
            "cosmoteer.control_room_med": { "mass": 9, "size": [3, 3], "cost": 25, "category": "", "cp_cost": 0 },
            "cosmoteer.thruster_small_2way": { "mass": 1.61, "size": [1, 1], "sprite_size": [2, 2], "cost": 1, "category": "thruster", "cp_cost": 2, "thrust": [0, 0.4, 0.4, 0] },
            "cosmoteer.control_room_large": { "mass": 16, "size": [4, 4], "cost": 50, "category": "", "cp_cost": 0 },
            "cosmoteer.thruster_small_3way": { "mass": 1.91, "size": [1, 1], "sprite_size": [3, 2], "cost": 1.5, "category": "thruster", "cp_cost": 3, "thrust": [0, 0.4, 0.4, 0.4] },
            "cosmoteer.hyperdrive_small": { "mass": 4, "size": [2, 2], "cost": 10, "category": "hyperdrive" },
            "cosmoteer.engine_room": { "mass": 9, "size": [3, 3], "cost": 12, "category": "", "cp_cost": 6 },
            "cosmoteer.crew_quarters_small": { "mass": 2, "size": [1, 2], "cost": 1.6, "category": "crew" },
            "cosmoteer.crew_quarters_med": { "mass": 4, "size": [2, 2], "cost": 4.2, "category": "crew" },
            "cosmoteer.airlock": { "mass": 1, "size": [1, 1], "cost": 0.6, "category": "" },
            "cosmoteer.conveyor": { "mass": 1, "size": [1, 1], "cost": 0.2, "category": "" },
            "cosmoteer.reactor_small": { "mass": 4, "size": [2, 2], "cost": 25, "category": "" },
            "cosmoteer.reactor_med": { "mass": 9, "size": [3, 3], "cost": 50, "category": "" },
            "cosmoteer.reactor_large": { "mass": 16, "size": [4, 4], "cost": 75, "category": "" },
            "cosmoteer.power_storage": { "mass": 4, "size": [2, 2], "cost": 4, "category": "" },
            "cosmoteer.factory_ammo": { "mass": 4, "size": [2, 2], "cost": 4.1, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_he": { "mass": 9, "size": [3, 3], "cost": 15.2, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_emp": { "mass": 12, "size": [3, 4], "cost": 20.5, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_nuke": { "mass": 16, "size": [4, 4], "cost": 27.1, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_mine": { "mass": 12, "size": [4, 3], "cost": 20.18, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_steel": { "mass": 16, "size": [4, 4], "cost": 30.4, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_coil": { "mass": 9, "size": [3, 3], "cost": 30.8, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_coil2": { "mass": 12, "size": [4, 3], "cost": 54.8, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_tristeel": { "mass": 16, "size": [4, 4], "cost": 68.2, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_diamond": { "mass": 6, "size": [2, 3], "cost": 53.2, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_processor": { "mass": 9, "size": [3, 3], "cost": 89, "category": "", "cp_cost": 1 },
            "cosmoteer.factory_uranium": { "mass": 12, "size": [3, 4], "cost": 98, "category": "", "cp_cost": 1 },
            "cosmoteer.storage_2x2": { "mass": 4, "size": [2, 2], "cost": 1.2, "category": "" },
            "cosmoteer.storage_3x2": { "mass": 6, "size": [3, 2], "cost": 1.8, "category": "" },
            "cosmoteer.storage_3x3": { "mass": 9, "size": [3, 3], "cost": 2.7, "category": "" },
            "cosmoteer.storage_4x3": { "mass": 12, "size": [4, 3], "cost": 3.6, "category": "" },
            "cosmoteer.storage_4x4": { "mass": 16, "size": [4, 4], "cost": 4.8, "category": "" },
            "cosmoteer.chaingun": { "mass": 17.77, "size": [3, 5], "sprite_size": [3, 7], "dps": 18000, "burst_damage": 0, "cost": 24, "category": "weapon", "cp_cost": 6 },
            "cosmoteer.chaingun_magazine": { "mass": 2, "size": [1, 2], "cost": 1, "category": "" },
            "cosmoteer.hyperdrive_large": { "mass": 16, "size": [4, 4], "cost": 34, "category": "hyperdrive" },
            "cosmoteer.thruster_rocket_battery": { "mass": 2, "size": [1, 2], "cost": 3, "category": "" },
            "cosmoteer.thruster_rocket_extender": { "mass": 6, "size": [3, 2], "cost": 6, "category": "thruster", "thrust": [0, 0, 8, 0] },
            "cosmoteer.thruster_rocket_nozzle": { "mass": 14.4, "size": [3, 4], "sprite_size": [3, 5], "cost": 15, "category": "thruster", "cp_cost": 16, "thrust": [0, 0, 8, 0] },
            "cosmoteer.hyperdrive_med": { "mass": 9, "size": [3, 3], "cost": 20, "category": "hyperdrive" },
            "cosmoteer.manipulator_beam_emitter": { "mass": 4, "size": [2, 2], "cost": 3, "category": "", "cp_cost": 4 },
            "cosmoteer.crew_quarters_large": { "mass": 12, "size": [3, 4], "cost": 15.6, "category": "crew" }
        };
        const upTurrets = [
            "cosmoteer.laser_blaster_small",
            "cosmoteer.laser_blaster_large",
            "cosmoteer.disruptor",
            "cosmoteer.ion_beam_emitter",
            "cosmoteer.ion_beam_prism",
            "cosmoteer.point_defense",
            "cosmoteer.cannon_med",
            "cosmoteer.cannon_large",
            "cosmoteer.cannon_deck",
            "cosmoteer.missile_launcher",
            "cosmoteer.railgun_launcher",
            "cosmoteer.flak_cannon_large",
            "cosmoteer.shield_gen_small",
            "cosmoteer.chaingun",
        ]
        const downTurrets = [
            "cosmoteer.thruster_small",
            "cosmoteer.thruster_med",
            "cosmoteer.thruster_large",
            "cosmoteer.thruster_huge",
            "cosmoteer.thruster_boost",
        ]
        const multiple_turrets = ["cosmoteer.thruster_small_2way", "cosmoteer.thruster_small_3way"]
        const cursor_mode = document.getElementsByName('cursor_mode');
        const json_import_text = document.getElementById('jsonInput');
        const load_json_button = document.getElementById('loadButton');
        const export_json_button = document.getElementById('exportButton');

        const shiplink = document.getElementById('ship_link');
        const generate_ship = document.getElementById('post_json');
        generate_ship.addEventListener('click', generateShip);

        const canvas = document.getElementById('spriteCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 64; // Size of each grid cell
        const spriteSelect = document.getElementById('spriteSelect');
        const spriteNames = Object.keys(spriteData).sort();
        for (const spriteName of spriteNames) {
            const option = document.createElement('option');
            option.value = spriteName;
            option.textContent = spriteName;
            spriteSelect.appendChild(option);
        }
        const property_select = document.getElementById('propertySelect');
        const property_edit = document.getElementById('propertyEdit');
        const apply_property_button = document.getElementById('applyPropertyButton');

        const ship_property_select = document.getElementById('shipPropertySelect');
        const ship_property_edit = document.getElementById('shipPropertyEdit');
        const apply_ship_property_button = document.getElementById('applyShipPropertyButton');

        const previewSpriteImage = new Image();
        const previewSprite = document.createElement('img');
        let ship_stats_label = document.getElementById('shipStatsLabel')
        let coordinates_label = document.getElementById('coord_on_canvas')

        previewSprite.id = 'previewSprite';
        document.body.appendChild(previewSprite);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('contextmenu', handleRightClick); // Listen for right-click
        export_json_button.addEventListener('click', export_json);
        load_json_button.addEventListener('click', loadJson);
        apply_property_button.addEventListener('click', applyProperty);

        apply_ship_property_button.addEventListener('click', applyShipProperty);

        cursor_mode.forEach((radio) => {
            radio.addEventListener('click', handleCursorMode);
        })
        // canvas.addEventListener('mousemove', handleCanvasMouseMove);
        document.getElementById('spriteSelect').addEventListener('change', handleSpriteSelectionChange);
        property_select.addEventListener('change', handlePropertySelectionChange);

        ship_property_select.addEventListener('change', handleShipPropertySelectionChange);

        let isPreviewSpriteLoaded = false; // init sprite preview
        let gridMap = {}; // To store the grid map
        let affectedSquares = []; // To store the affected squares
        let sprite_delete_mode = []; // To store the sprite delete mode
        let sprite_to_place = []; // To store the sprite to place
        let selected_sprites = [];
        let sprites = []; // To store the sprites
        let minX = 0, minY = 0, maxX = 0, maxY = 0; // adjust canvas size
        let shipdata = {}; // To store the ship data
        let deleteMode = false; // To store the delete mode
        let rotation = 0; // Initial rotation (0 degrees)
        let lastX = 0; // Last mouse position
        let lastY = 0; // Last mouse position
        let lastRotation = 0; // Last rotation
        let lastDrawX = 0; // Last preview sprite position
        let lastDrawY = 0; // Last preview sprite position
        let lastWidth = 0; // Last preview sprite size
        let lastHeight = 0; // Last preview sprite size
        let cursorMode = "Place"; // Initial cursor mode
        let doors = []; // To store the doors
        let resources = []; // To store the resources
        let part_toggles = [];

        // input and output for b64
        const b64Input = document.getElementById('b64_input');
        const loadB64Button = document.getElementById('load_b64');
        // get url parameter b64
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const b64 = urlParams.get('url');
        if (b64) {
            b64Input.value = b64;
            get_json();
        }

        loadB64Button.addEventListener('click', get_json);
        function get_json() {
            const b64Input = document.getElementById('b64_input');
            const encodedB64 = b64Input.value.replace(/-/g, '+').replace(/_/g, '/');
            const jsonInput = document.getElementById('jsonInput');
            const xhr = new XMLHttpRequest();
            const url = `https://cosmo-api-git-docker-franklin050187s-projects.vercel.app/edit?url=${encodedB64}`;
            xhr.open('GET', url, true);
            xhr.onload = function () {
                if (xhr.status === 200) {
                    jsonInput.value = xhr.responseText;
                    loadJson();
                }
            };

            xhr.send();
        }

        function generateShip() {
            // send post request to generate ship
            // use export json function to get shipdata
            export_json()
            // get the data
            const json_to_post = document.getElementById("json_export").value

            const xhr = new XMLHttpRequest();
            const url = 'https://cosmo-api-git-docker-franklin050187s-projects.vercel.app/generate';
            // const url = 'http://127.0.0.1:8001/generate';

            xhr.open('POST', url, true);
            // xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(json_to_post);

            xhr.onload = function () {
                if (xhr.status === 200) {
                    // console.log(xhr.responseText);
                    const ship_link = document.getElementById('ship_link');
                    const url = JSON.parse(xhr.responseText).url
                    ship_link.href = url
                    ship_link.style.display = 'block'
                }
            };
        }

        function handleCursorMode() {
            const cursor_mode = document.getElementsByName('cursor_mode');
            cursor_mode.forEach((radio) => {
                if (radio.checked) {
                    cursorMode = radio.value
                    handleCursorModeChange()
                }
            })
        }

        function handlePropertySelectionChange() {
            property_edit.value = JSON.parse(property_select.value).Value
        }

        function handleShipPropertySelectionChange() {
            ship_property_edit.value = ship_property_select.value
        }

        function handleCursorModeChange() {
            if (cursorMode == "Place") {
                // set <select id="spriteSelect"></select> to cosmoteer.corridor
                document.getElementById("spriteSelect").value = "cosmoteer.corridor";
                handleSpriteSelectionChange();
            }
            else if (cursorMode == "Delete") {
                // set <select id="spriteSelect"></select> to cosmoteer.corridor
                document.getElementById("spriteSelect").value = "cosmoteer.delete";
            }
        }

        function export_json() {
            // get shipdata, update shipdata.parts with sprites then export
            // drop "width" and "height" from sprite data
            new_parts = []
            sprites.forEach((sprite) => {
                delete sprite.width;
                delete sprite.height;
                new_parts.push(sprite)
            })
            shipdata.Doors = doors;
            shipdata.NewFlexResourceGridTypes = resources;
            shipdata.Parts = new_parts;
            shipdata.PartUIToggleStates = part_toggles;

            for ([key, value] of getShipDataMap()) {
                shipdata[key] = value;
            }

            // convert shipdata to json
            const json = JSON.stringify(shipdata);
            // clear textarea
            document.getElementById("json_export").value = "";
            // fill textarea id="json_export" with json string
            document.getElementById("json_export").value = json;
        }

        function loadJson() {
            // Clear the sprite data
            sprites = [];
            shipdata = {};
            doors = [];
            resources = [];
            part_toggles = [];
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = Array.isArray(data.Parts) ? data.Parts : [];
            const doordata = Array.isArray(data.Doors) ? data.Doors : [];
            const resource_data = Array.isArray(data.NewFlexResourceGridTypes) ? data.NewFlexResourceGridTypes : [];
            const partUIToggleStates = Array.isArray(data.PartUIToggleStates) ? data.PartUIToggleStates : [];

            shipdata = data
            // Calculate the min and max positions
            minX = Infinity;
            minY = Infinity;
            maxX = -Infinity;
            maxY = -Infinity;

            part_data.forEach(sprite => {
                const [x, y] = sprite.Location;
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                sprites.push(sprite);
            });

            doordata.forEach(door => {
                doors.push(door)
            });

            resource_data.forEach(resource => {
                resources.push(resource)
            });

            partUIToggleStates.forEach(toggle => {
                part_toggles.push(toggle)
            });

            updateShipToggleSelection();


            // Extend the grid by 10 squares in each direction
            minX -= 10;
            minY -= 10;
            maxX += 10;
            maxY += 10;

            // Adjust canvas size
            const width = (maxX - minX + 1) * gridSize;
            const height = (maxY - minY + 1) * gridSize;
            canvas.width = width;
            canvas.height = height;

            redrawCanvas();
        }

        function applyProperty() {
            new_value = property_edit.value;

            for (sprite of selected_sprites) {
                for (toggle of part_toggles) {
                    if (isSameToggleType(toggle, JSON.parse(property_select.value)) && toggleBelongsToSprite(toggle, sprite)) {
                        toggle.Value = new_value;
                    }
                }
            }

            redrawCanvas()
        }

        function applyShipProperty() {
            let new_value = ship_property_edit.value;
            let toggle = ship_property_select.options[ship_property_select.selectedIndex].text
            shipdata[toggle] = new_value
            updateShipToggleSelection();
            redrawCanvas();
        }

        function updateShipToggleSelection() {
            ship_property_select.innerHTML = '';
            for (let [key, toggle] of getShipDataMap()) {
                const option = document.createElement('option');
                option.value = toggle;
                option.textContent = key;
                ship_property_select.appendChild(option);
            }
            handleShipPropertySelectionChange();
        }

        function applyProperty() {
            new_value = property_edit.value;

            for (sprite of selected_sprites) {
                for (toggle of part_toggles) {
                    if (isSameToggleType(toggle, JSON.parse(property_select.value)) && toggleBelongsToSprite(toggle, sprite)) {
                        toggle.Value = new_value;
                    }
                }
            }

            redrawCanvas()
        }

        function sprite_position(part, position) {
            const sprite_size = spriteData[part["ID"]].sprite_size || spriteData[part["ID"]].size;
            const part_size = spriteData[part["ID"]].size;
            const part_rotation = part["Rotation"];

            if (part_rotation == 0 && upTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 3 && upTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 1 && downTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 2 && downTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (multiple_turrets.includes(part["ID"])) {
                if (part["ID"] == "cosmoteer.thruster_small_2way") {
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                    if (part_rotation == 2) {
                        position[0] -= 1;
                        position[1] -= 1;
                    }
                    if (part_rotation == 3) {
                        position[1] -= 1;
                    }
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                } else if (part["ID"] == "cosmoteer.thruster_small_3way") {
                    if (part_rotation == 2) {
                        if (part_rotation == 3) {
                            position[1] -= 1;
                        }
                    }
                }
            }
            if (part["ID"] == "cosmoteer.missile_launcher" && getPartDataMap(part).get("missile_type") != 0) {

                if (part_rotation == 0) {
                    position[1] -= 1;
                }
                if (part_rotation == 3) {
                    position[0] -= 1;
                }
            }
            if (part["ID"] == "cosmoteer.door") {
                if (part.Orientation == 0) {
                    position[1] -= 0.5;
                } else {
                    position[0] -= 0.5;
                }
            }
            return position;
        }

        function rotate_img(image, angle, flipx) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions based on the rotation
            if (angle % 2 === 0) {
                canvas.width = image.width;
                canvas.height = image.height;
            } else {
                canvas.width = image.height;
                canvas.height = image.width;
            }

            // Translate to center and rotate
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(angle * Math.PI / 2);

            if (flipx) {
                ctx.scale(-1, 1);
            }

            ctx.drawImage(image, -image.width / 2, -image.height / 2);

            return canvas;
        }

        function get_all_locations() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts

            let locations = []
            let width;
            let height;

            part_data.forEach(sprite => {
                getSpriteTileLocations(sprite)
                Array.prototype.push.apply(locations, sprite.Location);
            });
            return locations;
        }

        function draw_resources() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts

            if (resources == "Unset") {
                return
            }

            get_all_locations().forEach(location => {
                resources.forEach(resource => {
                    if (location[0] == resource.Key[0] && location[1] == resource.Key[1]) {
                        const imageName = resource.Value;
                        const img = new Image();

                        img.src = `sprites/${imageName}.png`;

                        img.onload = () => {
                            x = location[0];
                            y = location[1];
                            const rotatedImage = rotate_img(img, 0, false);
                            ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        };
                    }
                })
            })
        }

        function draw_doors() {
            doors.forEach(door => {
                const img = new Image();

                img.src = `sprites/door.png`;


                img.onload = () => {
                    rotation = (door.Orientation + 1) % 2;
                    let door_location = []
                    door_location[0] = door.Cell[0]
                    door_location[1] = door.Cell[1]
                    let location = sprite_position(door, door_location)
                    x = location[0];
                    y = location[1];
                    let angle = rotation

                    const rotatedImage = rotate_img(img, angle, false);
                    ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                };
            })
        }

        let spritesDrawn = new Set();

        const spriteCache = {};

        function preloadSprites() {
            // Iterate over the keys (IDs) in the spriteData object
            for (let spriteID of Object.keys(spriteData)) {
                const imageName = spriteID.replace("cosmoteer.", "");
                const img = new Image();
                img.src = `sprites/${imageName}.png`;
                spriteCache[imageName] = img; // Store the image in the cache
            }

            // Preload specific images for different missile types
            spriteCache["nuke_launcher"] = new Image();
            spriteCache["nuke_launcher"].src = `sprites/nuke_launcher.png`;

            spriteCache["emp_launcher"] = new Image();
            spriteCache["emp_launcher"].src = `sprites/emp_launcher.png`;

            spriteCache["mine_launcher"] = new Image();
            spriteCache["mine_launcher"].src = `sprites/mine_launcher.png`;
        }


        preloadSprites();

        function redrawCanvas() {
            const newSprites = sprites.filter(sprite => !spritesDrawn.has(sprite));
            const oldSprites = Array.from(spritesDrawn);
            spritesDrawn = new Set(sprites);

            // Clear old sprites
            oldSprites.forEach(sprite => {
                if (!spritesDrawn.has(sprite)) {
                    const [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                    ctx.clearRect(
                        (x - minX) * gridSize + 1,
                        (y - minY) * gridSize + 1,
                        sprite.width,
                        sprite.height
                    );
                }
            });

            // Draw new sprites
            newSprites.forEach(sprite => {
                const imageName = sprite["ID"].replace("cosmoteer.", "");
                const partData = getPartDataMap(sprite);
                const missileType = parseInt(partData.get("missile_type"));

                let img;
                if (missileType === 2) {
                    img = spriteCache["nuke_launcher"];
                } else if (missileType === 1) {
                    img = spriteCache["emp_launcher"];
                } else if (missileType === 3) {
                    img = spriteCache["mine_launcher"];
                } else {
                    img = spriteCache[imageName];
                }

                if (img) {
                    let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                    const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                    ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    sprite.width = rotatedImage.width;
                    sprite.height = rotatedImage.height;
                    square_map(sprite);
                }
            });

            updateShipStats();
            draw_doors();
            draw_resources();
        }


        function updateShipStats() {
            ship_stats_label.innerHTML = 'Weight :' + shipWeight().toFixed(0).toString() + 'kg<br>'
            ship_stats_label.innerHTML += 'Acceleration :' + shipAcceleration(0).toFixed(2).toString() + 'm/s^2<br>'
            ship_stats_label.innerHTML += 'Max speed :' + shipMaxSpeed(0).toFixed(2).toString() + 'm/s<br>'
            ship_stats_label.innerHTML += 'Thrust :' + shipThrustVector(0).toString() + 'N<br>'
            ship_stats_label.innerHTML += 'Cost :' + getShipCost().toFixed(0).toString() + '₡<br>'
            const commandPoints = getShipCommandPoints();
            const commandCost = getShipCommandCost();
            const commandPointText = `Command Points : ${commandCost}/${commandPoints}`;
            if (commandCost > commandPoints) {
                ship_stats_label.innerHTML += `<span style="color: red">${commandPointText}</span><br>`;
            } else {
                ship_stats_label.innerHTML += `${commandPointText}<br>`;
            }
            ship_stats_label.innerHTML += 'Crew :' + getCrew().toString() + '웃<br>'
            ship_stats_label.innerHTML += 'moment of inertia:' + momentOfInertiaShip().toString()+ 'kgm^2<br>'
            ship_stats_label.innerHTML += 'hyperdrive efficiency:' + (getShipHyperdriveEfficiency()*100).toString() + '%<br>'
            ship_stats_label.innerHTML += 'crew count:' + crewCount().toString() + '<br>'
            
        }

        function updateCoordinates(canvasPositionX, canvasPositionY) {
            coordinates_label.innerHTML = 'Coordinates : ' + canvasPositionX.toFixed(0).toString() + ',' + canvasPositionY.toFixed(0).toString();
        }

        function square_map(sprite) {
            const [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
            const width = Math.ceil(sprite.width / gridSize);
            const height = Math.ceil(sprite.height / gridSize);

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const squareX = x + i;
                    const squareY = y + j;
                    const key = `${squareX},${squareY}`;

                    gridMap[key] = {
                        square_x: squareX,
                        square_y: squareY,
                        is_drawn_by_sprite: sprite // Store the sprite that is using the square
                    };
                }
            }
        }

        function getPartDataMap(part) {
            let part_data = new Map()
            let raw_data = getPartData(part)

            for (const entry of raw_data) {
                const key = entry.Key || {};

                // Power toggle (1 is on 0 is off)
                if (key.includes("on_off")) {
                    part_data.set("on_off", entry.Value);
                }

                //fire mode (hold fire:2^32-1, fire at target: 1, fire at will: 0, autofire: 2)
                if (key.includes("fire_mode")) {
                    part_data.set("fire_mode", entry.Value);
                }

                //missile type (3 is mine, 1 is emp, 2 is nuke, 0 is he)
                if (key.includes("missile_type")) {
                    part_data.set("missile_type", entry.Value);
                }

            }

            return part_data

        }

        function loadPreviewSpriteImage() {
            const selectedSprite = document.getElementById('spriteSelect').value;
            const imageName = selectedSprite.replace("cosmoteer.", "");
            previewSpriteImage.src = `sprites/${imageName}.png`;

            previewSpriteImage.onload = () => {
                isPreviewSpriteLoaded = true;
            };
        }

        function handleCanvasMouseMove(event) {
            // fix position for flexbox
            const canvas = document.getElementById('spriteCanvas');
            const rect = canvas.getBoundingClientRect();

            // Calculate scaling factors between the canvas's original size and its displayed size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // Calculate mouse position relative to the canvas, taking into account the scaling
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            const mouseX = Math.floor(x / gridSize) * gridSize;
            const mouseY = Math.floor(y / gridSize) * gridSize;
            const canvasPositionX = (mouseX / gridSize) + minX;
            const canvasPositionY = (mouseY / gridSize) + minY;

            // update if square location changes
            if (lastX === canvasPositionX && lastY === canvasPositionY && lastRotation === rotation) {
                return;
            }

            updateCoordinates(canvasPositionX, canvasPositionY);

            if (cursorMode === 'Delete') {

                // load sprite
                const imageName = "delete";
                previewSpriteImage.src = `sprites/${imageName}.png`;

                previewSpriteImage.onload = () => {
                    isPreviewSpriteLoaded = true;
                };

                const spriteDataPreview = {
                    FlipX: false,
                    ID: "cosmoteer.delete",
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };
                previewSpriteImage.src = `sprites/${imageName}.png`;

                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);
                // Store affected grid squares
                affectedSquares = [];
                const width = 1;
                const height = 1;
                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                    }
                }
                // Find sprite data for affected squares and store it in sprite_delete_mode
                sprite_delete_mode = [];
                affectedSquares.forEach(key => {
                    if (gridMap[key]) {
                        sprite_delete_mode.push(gridMap[key].is_drawn_by_sprite);
                    }
                });
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;

                return;
            }

            if (cursorMode === 'Place') {
                sprite_to_place = [];
                if (!isPreviewSpriteLoaded) return;
                const spriteDataPreview = {
                    FlipX: false,
                    ID: document.getElementById('spriteSelect').value,
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };

                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);

                // Clear the previous preview sprite and redraw affected sprites
                clearPreview();

                // Draw the new preview sprite
                drawPreview(spriteDataPreview, (drawX - minX) * gridSize + 1, (drawY - minY) * gridSize + 1, rotatedImage);

                // Update last known position and dimensions
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;
                lastDrawX = (drawX - minX) * gridSize + 1;
                lastDrawY = (drawY - minY) * gridSize + 1;
                lastWidth = rotatedImage.width - 2;
                lastHeight = rotatedImage.height - 2;

                // Store affected grid squares
                affectedSquares = [];
                const width = Math.ceil(rotatedImage.width / gridSize);
                const height = Math.ceil(rotatedImage.height / gridSize);

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                    }
                }
                sprite_to_place = spriteDataPreview;
                return;
            }

            if (cursorMode === 'Move') {
                // get sprite under, call delete + place mode with that sprite and rotation
                const imageName = "delete";
                previewSpriteImage.src = `sprites/${imageName}.png`;
                previewSpriteImage.onload = () => {
                    isPreviewSpriteLoaded = true;
                };
                const spriteDataPreview = {
                    FlipX: false,
                    ID: "cosmoteer.delete",
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };
                previewSpriteImage.src = `sprites/${imageName}.png`;
                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);
                affectedSquares = [];
                const width = 1;
                const height = 1;
                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                    }
                }
                sprite_delete_mode = [];
                affectedSquares.forEach(key => {
                    if (gridMap[key]) {
                        sprite_delete_mode.push(gridMap[key].is_drawn_by_sprite);
                    }
                });
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;
                return;
            }
        }

        function clearPreview() {
            ctx.clearRect(lastDrawX, lastDrawY, lastWidth, lastHeight);

            // Redraw the sprites that were overwritten by the preview sprite
            affectedSquares.forEach(key => {
                if (gridMap[key]) {
                    const sprite = gridMap[key].is_drawn_by_sprite;
                    const imageName = sprite["ID"].replace("cosmoteer.", "");
                    const img = new Image();

                    const partData = getPartDataMap(sprite);
                    const missileType = partData.get("missile_type");
                    if (missileType === 2) {
                        img.src = `sprites/nuke_launcher.png`;
                    } else if (missileType === 1) {
                        img.src = `sprites/emp_launcher.png`;
                    } else if (missileType === 3) {
                        img.src = `sprites/mine_launcher.png`;
                    } else {
                        img.src = `sprites/${imageName}.png`;
                    }

                    img.onload = () => {
                        let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                        const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                        ctx.clearRect((x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    };
                }
            });
        }

        function drawPreview(spriteDataPreview, drawX, drawY, rotatedImage) {
            ctx.globalAlpha = 0.5;
            ctx.drawImage(rotatedImage, drawX, drawY, rotatedImage.width - 2, rotatedImage.height - 2);
            ctx.globalAlpha = 1.0;
        }

        function handleSpriteSelectionChange() {
            loadPreviewSpriteImage();
        }

        function handleCanvasClick(event) {
            // get positions
            const x = event.offsetX;
            const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize);
            const mouseY = Math.floor(y / gridSize);
            const canvas_position_x = Math.floor(mouseX - maxX + 1)
            const canvas_position_y = Math.floor(mouseY - maxY + 1)

            // place sprite
            if (cursorMode == "Place") {
                place_sprite(sprite_to_place);
                redrawCanvas();
            }
            // remove sprite
            if (cursorMode == "Delete") {
                if (sprite_delete_mode.length > 0) {
                    remove_from_sprites(sprite_delete_mode);
                    redrawCanvas();
                }

            }
            // move sprite
            if (cursorMode == "Move") {
                document.getElementById("spriteSelect").value = sprite_delete_mode[0].ID;
                rotation = sprite_delete_mode[0].Rotation;
                remove_from_sprites(sprite_delete_mode);
                redrawCanvas();
                loadPreviewSpriteImage();
                // isPreviewSpriteLoaded = false;
                cursorMode = "Place";
                // check the radio to place document.getElementsByName('cursor_mode')
                document.getElementById("Move").checked = false;
                document.getElementById("Place").checked = true;
            }
            // select sprite
            if (cursorMode == "Select") {

                let pos = mousePos(event)
                let selected_sprite = findSprite(pos[0], pos[1]);
                if (selected_sprite != null) {
                    select_sprite(selected_sprite)
                }

            }
        }

        function place_sprite(sprite_to_place) {

            let location = sprite_to_place.Location
            if (sprite_to_place["ID"] == "cosmoteer.door") {
                let string = JSON.parse(`{"Cell": [${location}], "ID": "cosmoteer.door", "Orientation": ${(sprite_to_place.Rotation + 1) % 2}}`)
                doors.push(string);
            } else {
                sprites.push(sprite_to_place);
            }
        }

        function select_sprite(sprite_to_select) {
            for (sprite of selected_sprites) {
                if (isSameSprite(sprite, sprite_to_select)) {
                    return;
                }
            }
            selected_sprites.push(sprite_to_select);
            updateSpriteSelection();
        }

        function resetSelectedSprites() {
            selected_sprites = [];
            updateSpriteSelection();
        }

        function updateSpriteSelection() {
            document.getElementById("selected_parts").innerText = `Selected sprites: `; //Update label
            let old_toggles = [];
            include_toggle = true;

            propertySelect.innerHTML = ''; //Update Selection 


            for (sprite of selected_sprites) {
                document.getElementById("selected_parts").innerText += sprite.ID + ", ";
                getPartData(sprite).forEach(toggle => {
                    for (old_toggle of old_toggles) {
                        if (isSameToggleType(old_toggle, toggle)) {
                            include_toggle = false;
                        }
                    }
                    if (include_toggle) {
                        const option = document.createElement('option');
                        let toggle_name = toggle.Key[1];

                        option.value = JSON.stringify(toggle);
                        option.textContent = toggle_name;
                        propertySelect.appendChild(option);

                        old_toggles.push(toggle)
                    } else {
                        include_toggle = true;
                    }

                })
            }

        }

        function select_sprite(sprite_to_select) {
            for (sprite of selected_sprites) {
                if (isSameSprite(sprite, sprite_to_select)) {
                    return;
                }
            }
            selected_sprites.push(sprite_to_select);
            updateSpriteSelection();
        }

        function resetSelectedSprites() {
            selected_sprites = [];
            updateSpriteSelection();
        }

        function updateSpriteSelection() {
            document.getElementById("selected_parts").innerText = `Selected sprites: `; //Update label
            let old_toggles = [];
            include_toggle = true;

            propertySelect.innerHTML = ''; //Update Selection 


            for (sprite of selected_sprites) {
                document.getElementById("selected_parts").innerText += sprite.ID + ", ";
                getPartData(sprite).forEach(toggle => {
                    for (old_toggle of old_toggles) {
                        if (isSameToggleType(old_toggle, toggle)) {
                            include_toggle = false;
                        }
                    }
                    if (include_toggle) {
                        const option = document.createElement('option');
                        let toggle_name = toggle.Key[1];

                        option.value = JSON.stringify(toggle);
                        option.textContent = toggle_name;
                        propertySelect.appendChild(option);

                        old_toggles.push(toggle)
                    } else {
                        include_toggle = true;
                    }

                })
            }

        }

        function remove_from_sprites(sprite_to_remove) {
            // console.log(sprite_to_remove);
            // console.log(gridMap)
            sprite_to_remove = sprite_to_remove[0];
            for (const sprite of sprites) {
                // find the sprite in sprites and remove it
                // check id and location
                if (isSameSprite(sprite, sprite_to_remove)) {
                    sprites.splice(sprites.indexOf(sprite), 1);
                    break;
                }
            }

            // remove from key from gridmap
            const key_loc_x = sprite_to_remove.Location[0]
            const key_loc_y = sprite_to_remove.Location[1]
            for (const key in gridMap) {
                if (gridMap[key].is_drawn_by_sprite.Location[0] == key_loc_x && gridMap[key].is_drawn_by_sprite.Location[1] == key_loc_y) {
                    // console.log("found key" + key);
                    delete gridMap[key];
                }
            }

        }

        function handleRightClick(event) {
            event.preventDefault();
            rotation = (rotation + 1) % 4;
            resetSelectedSprites()
            handleCanvasMouseMove(event); // Update the preview with new rotation
        }

        function clearPreviewSprite() {
            previewSprite.style.display = 'none'; // Hide the preview sprite
        }

        function unclearPreviewSprite() {
            previewSprite.style.display = 'block'; // Hide the preview sprite
        }


        function findSprite(x, y) {

            for (let sprite of sprites) {
                for (let location of getSpriteTileLocations(sprite)) {
                    if (location[0] == x && location[1] == y) {
                        return sprite;
                    }
                }
            }

            return null;

        }

        function getSpriteTileLocations(sprite) {
            const sprite_size = spriteData[sprite["ID"]].sprite_size || spriteData[sprite["ID"]].size;
            let locations = [];

            if (sprite.Rotation % 2 == 0) {
                width = sprite_size[0];
                height = sprite_size[1];
            } else {
                width = sprite_size[1];
                height = sprite_size[0];
            }

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    locations.push([sprite.Location[0] + i, sprite.Location[1] + j]);
                }
            }
            return locations;
        }

        function getPartData(part) {
            data = []
            for (const entry of part_toggles) {
                const key = entry.Key || {};
                if (part.Location[0] == key[0].Location[0] && part.Location[1] == key[0].Location[1]) {
                    data.push(entry);
                }
            }
            return data;
        }

        function getShipDataMap() {
            let filtered_ship_data = new Map();

            filtered_ship_data.set("Author", shipdata.Author);
            filtered_ship_data.set("FlightDirection", shipdata.FlightDirection);
            filtered_ship_data.set("Name", shipdata.Name);
            filtered_ship_data.set("DefaultAttackFollowAngle", shipdata.DefaultAttackFollowAngle);
            filtered_ship_data.set("DefaultAttackRadius", shipdata.DefaultAttackRadius);
            filtered_ship_data.set("DefaultAttackRotation", shipdata.DefaultAttackRotation);

            return filtered_ship_data;
        }

        function mousePos(event) {
            const canvas = document.getElementById('spriteCanvas');
            const rect = canvas.getBoundingClientRect();

            // Calculate scaling factors between the canvas's original size and its displayed size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // Calculate mouse position relative to the canvas, taking into account the scaling
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            // const x = event.offsetX;
            // const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize) * gridSize;
            const mouseY = Math.floor(y / gridSize) * gridSize;
            const canvasPositionX = (mouseX / gridSize) + minX;
            const canvasPositionY = (mouseY / gridSize) + minY;
            let result = [canvasPositionX, canvasPositionY]
            return result

        }

        // Initialize the canvas
        loadPreviewSpriteImage();
        // Initialize the grid
        // drawGrid();

        function isSameSprite(sprite1, sprite2) {
            if (sprite1.ID === sprite2.ID && sprite1.Location[0] == sprite2.Location[0] && sprite1.Location[1] == sprite2.Location[1]) {
                return true;
            } else {
                return false;
            }
        }


        function isSameToggleType(toggle1, toggle2) {
            return toggle1.Key[1] == toggle2.Key[1];
        }

        function toggleBelongsToSprite(toggle, sprite) {
            return isSameSprite(toggle.Key[0], sprite)
        }

        function getShipCost(id = null, category = null) {
            sum = 0;
            //regular part price
            for (sprite of getParts(id, category)) {
                sum += spriteData[sprite["ID"]].cost;
            }
            //extra costs from loaded missiles
            for (toggle of part_toggles) {
                if (toggle.Key[1] == "missile_type") {
                    if (toggle.Value == 0) {
                        sum += 0.096;
                    }
                    if (toggle.Value == 1) {
                        sum += 0.18;
                    }
                    if (toggle.Value == 2) {
                        sum += 0.432;
                    }
                    if (toggle.Value == 3) {
                        sum += 1.248;
                    }
                }
            }
            //Door costs 
            for (door of doors) {
                sum += 0.1;
            }
            return sum * 1000;
        }

        function getPartToggles(part) {
            toggles = [];
            for (toggle of part_toggles) {
                if (toggle.Key[0].ID == part["ID"]) {
                    toggles.push(toggle);
                }
            }
            return toggles;
        }

        function getShipCommandCost() {
            sum = 0
            for (sprite of sprites) {
                if (spriteData[sprite["ID"]].cp_cost > 0) {
                    sum += spriteData[sprite["ID"]].cp_cost
                }
            }
            return sum;
        }

        function getShipCommandPoints() {
            sum = 0
            for (sprite of sprites) {
                if (sprite["ID"] == "cosmoteer.control_room_small") {
                    sum += 50
                } else if (sprite["ID"] == "cosmoteer.control_room_med") {
                    sum += 250
                } else if (sprite["ID"] == "cosmoteer.control_room_large") {
                    sum += 1000
                }
            }
            return sum;
        }

        function getCrew() {
            sum = 0
            for (sprite of sprites) {
                if (sprite["ID"] == "cosmoteer.crew_quarters_small") {
                    sum += 2
                } else if (sprite["ID"] == "cosmoteer.crew_quarters_med") {
                    sum += 6
                } else if (sprite["ID"] == "cosmoteer.crew_quarters_large") {
                    sum += 24
                }
            }
            return sum
        }
        //Unfinished cause it seemed annoying to do and its not very important right now
        /*function getCGsMagsMap() {
            let mags = getParts("cosmoteer.chaingun_magazine")
            let cgs = getParts("cosmoteer.chaingun_magazine")
            let location = [0,0]
            for (cg_part of cgs) {
                for (mag_part of mags) {
                    if () {

                    }
                }
            }
        }*/

        function getParts(id = null, category = null) {
            parts = []
            for (sprite of sprites) {
                if ((sprite.ID == id || id == null) && (category == null || category == spriteData[sprite["ID"]].category)) {
                    parts.push(sprite)
                }
            }
            return parts
        }

        function shipWeight() {
            let sum = 0
            for (sprite of sprites) {
                sum += spriteData[sprite["ID"]].mass
            }
            return sum * 1000
        }

        function part_com_location(sprite) {
            let com_location = [0, 0]
            let part_rotation = sprite.Rotation
            let sprite_location = sprite.Location
            part_size = spriteData[sprite["ID"]].size

            if (part_rotation == 0 || part_rotation == 2) {
                com_location[0] = sprite_location[0] + part_size[0] / 2
                com_location[1] = sprite_location[1] + part_size[1] / 2
            } else {
                com_location[0] = sprite_location[0] + part_size[1] / 2
                com_location[1] = sprite_location[1] + part_size[0] / 2
            }
            return com_location
        }

        function ship_com_location() {
            let com = [0, 0]
            let part_com
            total_weight = shipWeight()
            for (part of sprites) {
                part_com = part_com_location(part)
                com[0] += part_com[0]
                com[1] += part_com[1]
            }
            com[0] /= total_weight
            com[1] /= total_weight
            return com
        }

        //Only supports whole number angles 
        function partThrustVector(part, angle) {
            let part_rotation = part.Rotation
            let thrust_vector = [0, 0, 0, 0]
            for (i of [0, 1, 2, 3]) {
                thrust_vector[i] = spriteData[part["ID"]].thrust[(i + part_rotation + 2) % 4] * 1000000;

            }
            return thrust_vector[angle]
        }

        function shipThrustVector(angle) {
            let thrust_vector = [0, 0, 0, 0]
            for (part of getParts(null, "thruster")) {
                thrust_vector[0] += partThrustVector(part, angle)
            }

            return thrust_vector
        }

        function shipMaxSpeed(angle) {
            let acceleration = shipAcceleration(angle)
            let speed_steps = 0.1
            for (i of Array(10000).keys()) {
                if (Math.max(i / 75, 1) ** 2 * 0.4 * i > acceleration) {
                    return i;
                }
            }
        }

        function shipAcceleration(angle) {
            let thrust = vecLength(shipThrustVector(angle))
            let mass = shipWeight()
            return thrust / mass
        }

        function vecLength(vec) {
            return Math.sqrt(vec[0]**2+vec[1]**2)
        }

        function pointDist(vec1, vec2) {
            return vecLength([vec1[0]-vec2[0], vec1[1]-vec2[1]]) 
        }

        function momentOfInertiaPart(part) {
            let [x0, y0] = ship_com_location()
            let location = part.Location
            let mass = spriteData[part["ID"]].mass
            return vecLength([location[0]-x0,location[1]-y0])*mass
        }

        function momentOfInertiaShip() {
            sum = 0
            for (part of sprites) {
                sum += momentOfInertiaPart(part)
            }
            return sum
        }

        function getTileHyperdriveEfficiency(part) {
            let hyperdrives = getParts(null, "hyperdrive")
            let sum = 0
            let JumpEfficiency = 0.5
            let JumpEfficiencyDistanceRange = 0
            let tileDist = []
            let part_center_location = partCenter(part)

            for (drive of hyperdrives) {
                switch (drive["ID"]) {
                    case ("cosmoteer.hyperdrive_small"): {
                        JumpEfficiencyDistanceRange = [5,30]
                        break
                    }
                    case ("cosmoteer.hyperdrive_med"): {
                        JumpEfficiencyDistanceRange = [10,60]
                        break
                    }
                    case ("cosmoteer.hyperdrive_large"): {
                        JumpEfficiencyDistanceRange = [20,120]
                        break
                    }
                }
                tileDist = pointDist(partCenter(drive), part_center_location)
                console.log(JumpEfficiencyDistanceRange)
                console.log(tileDist)
                sum += (1 - InverseLerp(JumpEfficiencyDistanceRange, tileDist)) * JumpEfficiency
            }
            return Math.min(sum, 1)
        }

        function getShipHyperdriveEfficiency() {
            let sum = 0
            for (part of sprites) {
                sum +=  getTileHyperdriveEfficiency(part)
            }
            return sum/sprites.length
        }

        function partCenter(part) {
            let size = spriteData[part["ID"]].size
            let location = part.Location
            return [part.Location[0] + size[0]/2, part.Location[1] + size[1]/2]
        }

        function InverseLerp(interval, delimiter) {
            if (interval[0]>delimiter) {
                return 0
            }
            if (interval[1]<delimiter) {
                return 1
            }
            return (delimiter - interval[0])/(interval[1]-interval[0])
        }

        function crewCount() {
            let sum = 0
            for (quarter of getParts(null, "crew")) {
                console.log(quarter.ID)
                switch (quarter.ID) { 
                    case "cosmoteer.crew_quarters_large": {
                        sum += 24
                    }
                    case "cosmoteer.crew_quarters_large": {
                        sum += 6
                    }
                    case "cosmoteer.crew_quarters_large": {
                        sum += 2
                    }
                }  
            }
            return sum
        }

        function getTileHyperdriveEfficiency(part) {
            let hyperdrives = getParts(null, "hyperdrive")
            let sum = 0
            let JumpEfficiency = 0.5
            let JumpEfficiencyDistanceRange = 0
            let tileDist = []
            let part_center_location = partCenter(part)

            for (drive of hyperdrives) {
                switch (drive["ID"]) {
                    case ("cosmoteer.hyperdrive_small"): {
                        JumpEfficiencyDistanceRange = [5,30]
                        break
                    }
                    case ("cosmoteer.hyperdrive_med"): {
                        JumpEfficiencyDistanceRange = [10,60]
                        break
                    }
                    case ("cosmoteer.hyperdrive_large"): {
                        JumpEfficiencyDistanceRange = [20,120]
                        break
                    }
                }
                tileDist = pointDist(partCenter(drive), part_center_location)
                console.log(JumpEfficiencyDistanceRange)
                console.log(tileDist)
                sum += (1 - InverseLerp(JumpEfficiencyDistanceRange, tileDist)) * JumpEfficiency
            }
            return Math.min(sum, 1)
        }

        function getShipHyperdriveEfficiency() {
            let sum = 0
            for (part of sprites) {
                sum +=  getTileHyperdriveEfficiency(part)
            }
            return sum/sprites.length
        }

        function partCenter(part) {
            let size = spriteData[part["ID"]].size
            let location = part.Location
            return [part.Location[0] + size[0]/2, part.Location[1] + size[1]/2]
        }

        function InverseLerp(interval, delimiter) {
            if (interval[0]>delimiter) {
                return 0
            }
            if (interval[1]<delimiter) {
                return 1
            }
            return (delimiter - interval[0])/(interval[1]-interval[0])
        }

        function crewCount() {
            let sum = 0
            for (quarter of getParts(null, "crew")) {
                console.log(quarter.ID)
                switch (quarter.ID) { 
                    case "cosmoteer.crew_quarters_large": {
                        sum += 24
                    }
                    case "cosmoteer.crew_quarters_large": {
                        sum += 6
                    }
                    case "cosmoteer.crew_quarters_large": {
                        sum += 2
                    }
                }  
            }
            return sum
        }
    </script>
</body>

</html>