<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Placement</title>
    <style>
        canvas {
            border: 1px solid #000;
        }

        #previewSprite {
            position: absolute;
            opacity: 0.7;
            pointer-events: none;
            /* Allow interaction with canvas below */
        }
    </style>
</head>

<body>
    <canvas id="spriteCanvas" width="64" height="64"></canvas>
    <textarea id="jsonInput"></textarea>
    <button id="loadButton">Load JSON</button>
    <label for="spriteSelect">Select a Sprite:</label>
    <select id="spriteSelect"></select>
    <button id="exportButton">Export json</button>
    <textarea name="json_export" id="json_export" disabled width="200" height="200"></textarea>
    <fieldset>
        <legend>Select a mode:</legend>
        <div>
            <input type="radio" id="Place" name="cursor_mode" value="Place" checked />
            <label for="Place">Place</label>
        </div>
        <div>
            <input type="radio" id="Select" name="cursor_mode" value="Select" />
            <label for="Select">Select</label>
        </div>
        <div>
            <input type="radio" id="Delete" name="cursor_mode" value="Delete" />
            <label for="Delete">Delete</label>
        </div>
        <div>
            <input type="radio" id="Move" name="cursor_mode" value="Move" />
            <label for="Move">Move</label>
        </div>
    </fieldset>


    <script>
        const spriteData = {
            "cosmoteer.corridor": { "mass": 1, "size": [1, 1] },
            "cosmoteer.delete": { "mass": 1, "size": [1, 1] },
            "cosmoteer.structure": { "mass": 0.33, "size": [1, 1] },
            "cosmoteer.structure_wedge": { "mass": 0.17, "size": [1, 1] },
            "cosmoteer.structure_1x2_wedge": { "mass": 0.33, "size": [1, 2] },
            "cosmoteer.structure_1x3_wedge": { "mass": 0.5, "size": [1, 3] },
            "cosmoteer.structure_tri": { "mass": 0.08, "size": [1, 1] },
            "cosmoteer.laser_blaster_small": { "mass": 2.5, "size": [1, 2], "sprite_size": [1, 4] },
            "cosmoteer.laser_blaster_large": { "mass": 7.68, "size": [2, 3], "sprite_size": [2, 6] },
            "cosmoteer.disruptor": { "mass": 3.48, "size": [1, 3], "sprite_size": [1, 5] },
            "cosmoteer.ion_beam_emitter": { "mass": 8, "size": [2, 4], "sprite_size": [2, 5] },
            "cosmoteer.resource_collector": { "mass": 4, "size": [2, 2] },
            "cosmoteer.ion_beam_prism": { "mass": 7.7, "size": [2, 2], "sprite_size": [2, 2.5] },
            "cosmoteer.tractor_beam_emitter": { "mass": 32.07, "size": [5, 5] },
            "cosmoteer.point_defense": { "mass": 1, "size": [1, 1], "sprite_size": [1, 2] },
            "cosmoteer.mining_laser_small": { "mass": 7.4, "size": [2, 3] },
            "cosmoteer.cannon_med": { "mass": 4.44, "size": [2, 1], "sprite_size": [2, 3] },
            "cosmoteer.sensor_array": { "mass": 11.54, "size": [3, 3] },
            "cosmoteer.cannon_large": { "mass": 12.29, "size": [3, 2], "sprite_size": [3, 5] },
            "cosmoteer.hyperdrive_beacon": { "mass": 17.13, "size": [4, 4] },
            "cosmoteer.cannon_deck": { "mass": 27.07, "size": [4, 5], "sprite_size": [4, 7] },
            "cosmoteer.explosive_charge": { "mass": 1, "size": [1, 1] },
            "cosmoteer.roof_light": { "mass": 1, "size": [1, 1] },
            "cosmoteer.missile_launcher": { "mass": 8, "size": [2, 3], "sprite_size": [2, 4] },
            "cosmoteer.roof_headlight": { "mass": 1, "size": [1, 1] },
            "cosmoteer.railgun_loader": { "mass": 24, "size": [2, 3] },
            "cosmoteer.armor_structure_hybrid_1x1": { "mass": 1.5, "size": [1, 1] },
            "cosmoteer.armor_structure_hybrid_1x2": { "mass": 3, "size": [1, 2] },
            "cosmoteer.railgun_accelerator": { "mass": 36, "size": [2, 3] },
            "cosmoteer.armor_structure_hybrid_1x3": { "mass": 4.5, "size": [1, 3] },
            "cosmoteer.armor_structure_hybrid_tri": { "mass": 1, "size": [1, 1] },
            "cosmoteer.railgun_launcher": { "mass": 36, "size": [2, 3], "sprite_size": [2, 4] },
            "cosmoteer.armor": { "mass": 3, "size": [1, 1] },
            "cosmoteer.armor_2x1": { "mass": 6, "size": [2, 1] },
            "cosmoteer.flak_cannon_large": { "mass": 16.77, "size": [3, 6], "sprite_size": [3, 8] },
            "cosmoteer.armor_wedge": { "mass": 1.5, "size": [1, 1] },
            "cosmoteer.armor_1x2_wedge": { "mass": 3, "size": [1, 2] },
            "cosmoteer.shield_gen_small": { "mass": 6, "size": [2, 2], "sprite_size": [2, 3] },
            "cosmoteer.armor_1x3_wedge": { "mass": 4.5, "size": [1, 3] },
            "cosmoteer.armor_tri": { "mass": 0.75, "size": [1, 1] },
            "cosmoteer.shield_gen_large": { "mass": 12.65, "size": [3, 6] },
            "cosmoteer.thruster_small": { "mass": 1.3, "size": [1, 1], "sprite_size": [1, 2] },
            "cosmoteer.thruster_med": { "mass": 2.45, "size": [1, 2], "sprite_size": [1, 3] },
            "cosmoteer.thruster_large": { "mass": 4.99, "size": [2, 2], "sprite_size": [2, 3] },
            "cosmoteer.thruster_boost": { "mass": 8.88, "size": [2, 3], "sprite_size": [2, 5] },
            "cosmoteer.fire_extinguisher": { "mass": 1, "size": [1, 1] },
            "cosmoteer.thruster_huge": { "mass": 11, "size": [3, 3], "sprite_size": [3, 5] },
            "cosmoteer.control_room_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.control_room_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.thruster_small_2way": { "mass": 1.61, "size": [1, 1], "sprite_size": [2, 2] },
            "cosmoteer.control_room_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.thruster_small_3way": { "mass": 1.91, "size": [1, 1], "sprite_size": [3, 2] },
            "cosmoteer.hyperdrive_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.engine_room": { "mass": 9, "size": [3, 3] },
            "cosmoteer.crew_quarters_small": { "mass": 2, "size": [1, 2] },
            "cosmoteer.crew_quarters_med": { "mass": 4, "size": [2, 2] },
            "cosmoteer.airlock": { "mass": 1, "size": [1, 1] },
            "cosmoteer.conveyor": { "mass": 1, "size": [1, 1] },
            "cosmoteer.reactor_small": { "mass": 4, "size": [2, 2] },
            "cosmoteer.reactor_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.reactor_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.power_storage": { "mass": 4, "size": [2, 2] },
            "cosmoteer.factory_ammo": { "mass": 4, "size": [2, 2] },
            "cosmoteer.factory_he": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_emp": { "mass": 12, "size": [3, 4] },
            "cosmoteer.factory_nuke": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_mine": { "mass": 12, "size": [4, 3] },
            "cosmoteer.factory_steel": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_coil": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_coil2": { "mass": 12, "size": [4, 3] },
            "cosmoteer.factory_tristeel": { "mass": 16, "size": [4, 4] },
            "cosmoteer.factory_diamond": { "mass": 6, "size": [2, 3] },
            "cosmoteer.factory_processor": { "mass": 9, "size": [3, 3] },
            "cosmoteer.factory_uranium": { "mass": 12, "size": [3, 4] },
            "cosmoteer.storage_2x2": { "mass": 4, "size": [2, 2] },
            "cosmoteer.storage_3x2": { "mass": 6, "size": [3, 2] },
            "cosmoteer.storage_3x3": { "mass": 9, "size": [3, 3] },
            "cosmoteer.storage_4x3": { "mass": 12, "size": [4, 3] },
            "cosmoteer.storage_4x4": { "mass": 16, "size": [4, 4] },
            "cosmoteer.chaingun": { "mass": 17.77, "size": [3, 5], "sprite_size": [3, 7] },
            "cosmoteer.chaingun_magazine": { "mass": 2, "size": [1, 2] },
            "cosmoteer.hyperdrive_large": { "mass": 16, "size": [4, 4] },
            "cosmoteer.thruster_rocket_battery": { "mass": 2, "size": [1, 2] },
            "cosmoteer.thruster_rocket_extender": { "mass": 6, "size": [3, 2] },
            "cosmoteer.thruster_rocket_nozzle": { "mass": 14.4, "size": [3, 4], "sprite_size": [3, 5] },
            "cosmoteer.hyperdrive_med": { "mass": 9, "size": [3, 3] },
            "cosmoteer.manipulator_beam_emitter": { "mass": 4, "size": [2, 2] },
            "cosmoteer.crew_quarters_large": { "mass": 12, "size": [3, 4] }
        };
        const upTurrets = [
            "cosmoteer.laser_blaster_small",
            "cosmoteer.laser_blaster_large",
            "cosmoteer.disruptor",
            "cosmoteer.ion_beam_emitter",
            "cosmoteer.ion_beam_prism",
            "cosmoteer.point_defense",
            "cosmoteer.cannon_med",
            "cosmoteer.cannon_large",
            "cosmoteer.cannon_deck",
            "cosmoteer.missile_launcher",
            "cosmoteer.railgun_launcher",
            "cosmoteer.flak_cannon_large",
            "cosmoteer.shield_gen_small",
            "cosmoteer.chaingun",
        ]
        const downTurrets = [
            "cosmoteer.thruster_small",
            "cosmoteer.thruster_med",
            "cosmoteer.thruster_large",
            "cosmoteer.thruster_huge",
            "cosmoteer.thruster_boost",
        ]
        const multiple_turrets = ["cosmoteer.thruster_small_2way", "cosmoteer.thruster_small_3way"]
        const cursor_mode = document.getElementsByName('cursor_mode');
        const json_import_text = document.getElementById('jsonInput');
        const load_json_button = document.getElementById('loadButton');
        const export_json_button = document.getElementById('exportButton');
        const canvas = document.getElementById('spriteCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 64; // Size of each grid cell
        const spriteSelect = document.getElementById('spriteSelect');
        for (const spriteName in spriteData) {
            const option = document.createElement('option');
            option.value = spriteName;
            option.textContent = spriteName;
            spriteSelect.appendChild(option);
        }
        const previewSpriteImage = new Image();
        const previewSprite = document.createElement('img');
        previewSprite.id = 'previewSprite';
        document.body.appendChild(previewSprite);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('contextmenu', handleRightClick); // Listen for right-click
        export_json_button.addEventListener('click', export_json);
        load_json_button.addEventListener('click', loadJson);
        cursor_mode.forEach((radio) => {
            radio.addEventListener('click', handleCursorMode);
        })
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        document.getElementById('spriteSelect').addEventListener('change', handleSpriteSelectionChange);

        let isPreviewSpriteLoaded = false; // init sprite preview
        let gridMap = {}; // To store the grid map
        let affectedSquares = []; // To store the affected squares
        let sprite_delete_mode = []; // To store the sprite delete mode
        let sprite_to_place = []; // To store the sprite to place
        let sprites = []; // To store the sprites
        let minX = 0, minY = 0, maxX = 0, maxY = 0; // adjust canvas size
        let shipdata = {}; // To store the ship data
        let deleteMode = false; // To store the delete mode
        let rotation = 0; // Initial rotation (0 degrees)
        let lastX = 0; // Last mouse position
        let lastY = 0; // Last mouse position
        let lastRotation = 0; // Last rotation
        let lastDrawX = 0; // Last preview sprite position
        let lastDrawY = 0; // Last preview sprite position
        let lastWidth = 0; // Last preview sprite size
        let lastHeight = 0; // Last preview sprite size
        let cursorMode = "Place"; // Initial cursor mode
        let doors = []; // To store the doors
        let resources = []; // To store the resources

        function handleCursorMode() {
            const cursor_mode = document.getElementsByName('cursor_mode');
            cursor_mode.forEach((radio) => {
                if (radio.checked) {
                    cursorMode = radio.value
                    handleCursorModeChange()
                }
            })
            // console.log(cursorMode)
        }

        function handleCursorModeChange() {
            if (cursorMode == "Place") {
                // set <select id="spriteSelect"></select> to cosmoteer.corridor
                document.getElementById("spriteSelect").value = "cosmoteer.corridor";
                handleSpriteSelectionChange();
            }
            else if (cursorMode == "Delete") {
                // set <select id="spriteSelect"></select> to cosmoteer.corridor
                document.getElementById("spriteSelect").value = "cosmoteer.delete";
            }
        }

        function export_json() {
            // get shipdata, update shipdata.parts with sprites then export
            // drop "width" and "height" from sprite data
            new_parts = []
            sprites.forEach((sprite) => {
                delete sprite.width;
                delete sprite.height;
                new_parts.push(sprite)
            })
            shipdata.Doors = doors;
            shipdata.NewFlexResourceGridTypes = resources;
            shipdata.Parts = new_parts;
            // console.log(shipdata)
            // convert shipdata to json
            const json = JSON.stringify(shipdata);
            // console.log(json);
            // clear textarea
            document.getElementById("json_export").value = "";
            // fill textarea id="json_export" with json string
            document.getElementById("json_export").value = json;
        }

        function drawGrid() {
            ctx.strokeStyle = '#ccc';
            ctx.font = '12px Arial';
            ctx.fillStyle = '#000';

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    const xPos = (x - minX) * gridSize;
                    const yPos = (y - minY) * gridSize;
                    ctx.strokeRect(xPos, yPos, gridSize, gridSize);

                    // Draw coordinates
                    ctx.fillText(`(${x},${y})`, xPos + 2, yPos + 12);
                }
            }
        }

        function loadJson() {
            // Clear the sprite data
            sprites = [];
            shipdata = {};
            doors = [];
            resources = [];
            const json = json_import_text.value;
            // console.log(json);
            const data = JSON.parse(json);
            const part_data = data.Parts || [];
            const doordata = Array.isArray(data.Doors) ? data.Doors : [];
            const resource_data = Array.isArray(data.NewFlexResourceGridTypes) ? data.NewFlexResourceGridTypes : [];

            shipdata = data
            // Calculate the min and max positions
            minX = Infinity;
            minY = Infinity;
            maxX = -Infinity;
            maxY = -Infinity;

            part_data.forEach(sprite => {
                const [x, y] = sprite.Location;
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                sprites.push(sprite);
            });

            doordata.forEach(door => {
                doors.push(door)
            });

            resource_data.forEach(resource => {
                resources.push(resource)
            });

            // Extend the grid by 10 squares in each direction
            minX -= 10;
            minY -= 10;
            maxX += 10;
            maxY += 10;

            // Adjust canvas size
            const width = (maxX - minX + 1) * gridSize;
            const height = (maxY - minY + 1) * gridSize;
            canvas.width = width;
            canvas.height = height;

            redrawCanvas();
        }

        function sprite_position(part, position) {
            const sprite_size = spriteData[part["ID"]].sprite_size || spriteData[part["ID"]].size;
            const part_size = spriteData[part["ID"]].size;
            const part_rotation = part["Rotation"];

            if (part_rotation == 0 && upTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 3 && upTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 1 && downTurrets.includes(part["ID"])) {
                position[0] -= sprite_size[1] - part_size[1];
            } else if (part_rotation == 2 && downTurrets.includes(part["ID"])) {
                position[1] -= sprite_size[1] - part_size[1];
            } else if (multiple_turrets.includes(part["ID"])) {
                if (part["ID"] == "cosmoteer.thruster_small_2way") {
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                    if (part_rotation == 2) {
                        position[0] -= 1;
                        position[1] -= 1;
                    }
                    if (part_rotation == 3) {
                        position[1] -= 1;
                    }
                    if (part_rotation == 1) {
                        position[0] -= 1;
                    }
                } else if (part["ID"] == "cosmoteer.thruster_small_3way") {
                    if (part_rotation == 2) {
                        if (part_rotation == 3) {
                            position[1] -= 1;
                        }
                    }
                }
            }
            if (part["ID"] == "cosmoteer.missile_launcher" && getPartData(part).get("missile_type") != 0) {

                if (part_rotation == 0) {
                    position[1] -= 1;
                }
                if (part_rotation == 3) {
                    position[0] -= 1;
                }
            }
            return position;
        }

        function rotate_img(image, angle, flipx) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions based on the rotation
            if (angle % 2 === 0) {
                canvas.width = image.width;
                canvas.height = image.height;
            } else {
                canvas.width = image.height;
                canvas.height = image.width;
            }

            // Translate to center and rotate
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(angle * Math.PI / 2);

            if (flipx) {
                ctx.scale(-1, 1);
            }

            ctx.drawImage(image, -image.width / 2, -image.height / 2);

            return canvas;
        }

        function get_all_locations() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts

            let locations = []
            let width;
            let height;

            part_data.forEach(sprite => {
                const sprite_size = spriteData[sprite["ID"]].sprite_size || spriteData[sprite["ID"]].size;

                if (sprite.Rotation % 2 == 0) {
                    width = sprite_size[0];
                    height = sprite_size[1];
                } else {
                    width = sprite_size[1];
                    height = sprite_size[0];
                }

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        locations.push([sprite.Location[0] + i, sprite.Location[1] + j]);
                    }
                }

                locations.push(sprite.Location)
            });
            return locations;
        }

        function draw_resources() {
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const part_data = data.Parts
            // const resource_data = data.NewFlexResourceGridTypes
            // console.log(resource_data)
            if (resources == "Unset") {
                return
            }

            get_all_locations().forEach(location => {
                resources.forEach(resource => {
                    if (location[0] == resource.Key[0] && location[1] == resource.Key[1]) {
                        const imageName = resource.Value;
                        const img = new Image();

                        img.src = `sprites/${imageName}.png`;

                        img.onload = () => {
                            // console.log(location[0])
                            // console.log(resource.Key[0])
                            x = location[0];
                            y = location[1];
                            const rotatedImage = rotate_img(img, 0, false);
                            ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        };
                    }
                })
            })
        }

        function draw_doors() {
            console.log(doors)
            doors.forEach(door => {
                const img = new Image();

                img.src = `sprites/door.png`;
                // console.log("door")
                img.onload = () => {
                    // console.log("loaded")
                    x = door.Cell[0];
                    y = door.Cell[1];
                    let angle = 0
                    if (door.Orientation == 0) {
                        y -= 0.5
                        angle = 1
                    } else {
                        x -= 0.5
                    }
                    const rotatedImage = rotate_img(img, angle, false);
                    ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                };
            })
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            drawGrid(); // Redraw the grid
            gridMap = {}; // Reset the grid map
            sprites.forEach(sprite => {
                const imageName = sprite["ID"].replace("cosmoteer.", "");
                const img = new Image();

                const partData = getPartData(sprite);
                const missileType = partData.get("missile_type");

                if (missileType === 2) {
                    img.src = `sprites/nuke_launcher.png`;
                } else if (missileType === 1) {
                    img.src = `sprites/emp_launcher.png`;
                } else if (missileType === 3) {
                    img.src = `sprites/mine_launcher.png`;
                } else {
                    img.src = `sprites/${imageName}.png`;
                }

                img.onload = () => {
                    let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                    const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                    ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    sprite.width = rotatedImage.width;
                    sprite.height = rotatedImage.height;
                    square_map(sprite);
                };
            });
            draw_resources();
            draw_doors();
        }

        function square_map(sprite) {
            const [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
            const width = Math.ceil(sprite.width / gridSize);
            const height = Math.ceil(sprite.height / gridSize);

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const squareX = x + i;
                    const squareY = y + j;
                    const key = `${squareX},${squareY}`;

                    gridMap[key] = {
                        square_x: squareX,
                        square_y: squareY,
                        is_drawn_by_sprite: sprite // Store the sprite that is using the square
                    };
                }
            }
        }

        function getPartData(part) {
            let part_data = new Map()
            const json = json_import_text.value;
            const data = JSON.parse(json);
            const partUIToggleStates = data.PartUIToggleStates || [];

            // if "PartUIToggleStates": "Unset", then skip
            if (partUIToggleStates === "Unset") {
                return part_data
            }
            for (const entry of partUIToggleStates) {
                const key = entry.Key || {};


                if (part.Location[0] == key[0].Location[0] && part.Location[1] == key[0].Location[1]) {

                    // Power toggle (1 is on 0 is off)
                    if (key.includes("on_off")) {
                        part_data.set("on_off", entry.Value);
                    }

                    //fire mode (hold fire:2^32-1, fire at target: 1, fire at will: 0, autofire: 2)
                    if (key.includes("fire_mode")) {
                        part_data.set("fire_mode", entry.Value);
                    }

                    //missile type (3 is mine, 1 is emp, 2 is nuke, 0 is he)
                    if (key.includes("missile_type")) {
                        part_data.set("missile_type", entry.Value);
                    }
                }

            }

            return part_data

        }

        function loadPreviewSpriteImage() {
            const selectedSprite = document.getElementById('spriteSelect').value;
            const imageName = selectedSprite.replace("cosmoteer.", "");
            previewSpriteImage.src = `sprites/${imageName}.png`;

            previewSpriteImage.onload = () => {
                isPreviewSpriteLoaded = true;
            };
        }

        function handleCanvasMouseMove(event) {
            // init mouse and cavas location
            const x = event.offsetX;
            const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize) * gridSize;
            const mouseY = Math.floor(y / gridSize) * gridSize;
            const canvasPositionX = (mouseX / gridSize) + minX;
            const canvasPositionY = (mouseY / gridSize) + minY;
            // update if square location changes
            if (lastX === canvasPositionX && lastY === canvasPositionY && lastRotation === rotation) {
                return;
            }

            if (cursorMode === 'Delete') {

                // load sprite
                const imageName = "delete";
                previewSpriteImage.src = `sprites/${imageName}.png`;

                previewSpriteImage.onload = () => {
                    isPreviewSpriteLoaded = true;
                };

                const spriteDataPreview = {
                    FlipX: false,
                    ID: "cosmoteer.delete",
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };
                previewSpriteImage.src = `sprites/${imageName}.png`;

                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);
                // Store affected grid squares
                affectedSquares = [];
                const width = 1;
                const height = 1;
                // console.log("width", width, "height", height);
                // console.log("canvasPositionX", canvasPositionX, "canvasPositionY", canvasPositionY);
                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                        // console.log("key", key);

                    }
                }
                // console.log("affectedSquares", affectedSquares);
                // Find sprite data for affected squares and store it in sprite_delete_mode
                sprite_delete_mode = [];
                affectedSquares.forEach(key => {
                    if (gridMap[key]) {
                        sprite_delete_mode.push(gridMap[key].is_drawn_by_sprite);
                    }
                });
                // console.log("sprite_delete_mode", sprite_delete_mode);
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;

                return;
            }

            if (cursorMode === 'Place') {
                sprite_to_place = [];
                if (!isPreviewSpriteLoaded) return;
                const spriteDataPreview = {
                    FlipX: false,
                    ID: document.getElementById('spriteSelect').value,
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };

                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);

                // Clear the previous preview sprite and redraw affected sprites
                clearPreview();

                // Draw the new preview sprite
                drawPreview(spriteDataPreview, (drawX - minX) * gridSize + 1, (drawY - minY) * gridSize + 1, rotatedImage);

                // Update last known position and dimensions
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;
                lastDrawX = (drawX - minX) * gridSize + 1;
                lastDrawY = (drawY - minY) * gridSize + 1;
                lastWidth = rotatedImage.width - 2;
                lastHeight = rotatedImage.height - 2;

                // Store affected grid squares
                affectedSquares = [];
                const width = Math.ceil(rotatedImage.width / gridSize);
                const height = Math.ceil(rotatedImage.height / gridSize);

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                    }
                }
                sprite_to_place = spriteDataPreview;
                return;
            }

            if (cursorMode === 'Move') {
                // get sprite under, call delete + place mode with that sprite and rotation
                const imageName = "delete";
                previewSpriteImage.src = `sprites/${imageName}.png`;
                previewSpriteImage.onload = () => {
                    isPreviewSpriteLoaded = true;
                };
                const spriteDataPreview = {
                    FlipX: false,
                    ID: "cosmoteer.delete",
                    Location: [canvasPositionX, canvasPositionY],
                    Rotation: rotation
                };
                previewSpriteImage.src = `sprites/${imageName}.png`;
                let [drawX, drawY] = sprite_position(spriteDataPreview, [spriteDataPreview.Location[0], spriteDataPreview.Location[1]]);
                const rotatedImage = rotate_img(previewSpriteImage, spriteDataPreview.Rotation, spriteDataPreview.FlipX);
                affectedSquares = [];
                const width = 1;
                const height = 1;
                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        const squareX = canvasPositionX + i;
                        const squareY = canvasPositionY + j;
                        const key = `${squareX},${squareY}`;
                        affectedSquares.push(key);
                    }
                }
                sprite_delete_mode = [];
                affectedSquares.forEach(key => {
                    if (gridMap[key]) {
                        sprite_delete_mode.push(gridMap[key].is_drawn_by_sprite);
                    }
                });
                lastX = canvasPositionX;
                lastY = canvasPositionY;
                lastRotation = rotation;
                return;
            }
        }

        function clearPreview() {
            // console.log("clearPreview")
            ctx.clearRect(lastDrawX, lastDrawY, lastWidth, lastHeight);

            // Redraw the sprites that were overwritten by the preview sprite
            affectedSquares.forEach(key => {
                if (gridMap[key]) {
                    const sprite = gridMap[key].is_drawn_by_sprite;
                    const imageName = sprite["ID"].replace("cosmoteer.", "");
                    const img = new Image();

                    const partData = getPartData(sprite);
                    const missileType = partData.get("missile_type");

                    if (missileType === 2) {
                        img.src = `sprites/nuke_launcher.png`;
                    } else if (missileType === 1) {
                        img.src = `sprites/emp_launcher.png`;
                    } else if (missileType === 3) {
                        img.src = `sprites/mine_launcher.png`;
                    } else {
                        img.src = `sprites/${imageName}.png`;
                    }

                    img.onload = () => {
                        let [x, y] = sprite_position(sprite, [sprite.Location[0], sprite.Location[1]]);
                        const rotatedImage = rotate_img(img, sprite.Rotation, sprite.FlipX);
                        ctx.clearRect((x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                        ctx.drawImage(rotatedImage, (x - minX) * gridSize + 1, (y - minY) * gridSize + 1, rotatedImage.width - 2, rotatedImage.height - 2);
                    };
                }
            });
        }

        function drawPreview(spriteDataPreview, drawX, drawY, rotatedImage) {
            ctx.globalAlpha = 0.5;
            ctx.drawImage(rotatedImage, drawX, drawY, rotatedImage.width - 2, rotatedImage.height - 2);
            ctx.globalAlpha = 1.0;
        }

        function handleSpriteSelectionChange() {
            loadPreviewSpriteImage();
        }

        function handleCanvasClick(event) {
            // get positions
            const x = event.offsetX;
            const y = event.offsetY;
            const mouseX = Math.floor(x / gridSize);
            const mouseY = Math.floor(y / gridSize);
            const canvas_position_x = Math.floor(mouseX - maxX + 1)
            const canvas_position_y = Math.floor(mouseY - maxY + 1)

            // place sprite
            if (cursorMode == "Place") {
                place_sprite(sprite_to_place);
                redrawCanvas();
            }
            // remove sprite
            if (cursorMode == "Delete") {
                if (sprite_delete_mode.length > 0) {
                    remove_from_sprites(sprite_delete_mode);
                    redrawCanvas();
                }

            }
            // move sprite
            if (cursorMode == "Move") {
                document.getElementById("spriteSelect").value = sprite_delete_mode[0].ID;
                rotation = sprite_delete_mode[0].Rotation;
                // console.log("sprite_move", sprite_delete_mode);
                // console.log("rotation", rotation);
                // console.log("sprite_ID", sprite_delete_mode[0].ID);
                remove_from_sprites(sprite_delete_mode);
                redrawCanvas();
                loadPreviewSpriteImage();
                // isPreviewSpriteLoaded = false;
                cursorMode = "Place";
                // check the radio to place document.getElementsByName('cursor_mode')
                document.getElementById("Move").checked = false;
                document.getElementById("Place").checked = true;
            }

        }

        function place_sprite(sprite_to_place) {
            // console.log("sprite_to_place", sprite_to_place);
            sprites.push(sprite_to_place);
        }

        function remove_from_sprites(sprite_to_remove) {
            // console.log("sprite_to_remove", sprite_to_remove);
            sprite_to_remove = sprite_to_remove[0];
            // console.log("sprites (rm)", sprites);
            for (const sprite of sprites) {
                // console.log("sprite_rm", sprite_to_remove[0]);
                // console.log("sprite (rm)", sprite);
                // find the sprite in sprites and remove it
                // check id and location
                if (sprite.ID === sprite_to_remove.ID && sprite.Location[0] === sprite_to_remove.Location[0] && sprite.Location[1] === sprite_to_remove.Location[1]) {
                    // console.log("sprite removed", sprite);
                    sprites.splice(sprites.indexOf(sprite), 1);
                    break;
                }
            }
        }

        function handleRightClick(event) {
            event.preventDefault();
            rotation = (rotation + 1) % 4;
            handleCanvasMouseMove(event); // Update the preview with new rotation
        }

        function clearPreviewSprite() {
            previewSprite.style.display = 'none'; // Hide the preview sprite
        }

        function unclearPreviewSprite() {
            previewSprite.style.display = 'block'; // Hide the preview sprite
        }

        // Initialize the canvas
        loadPreviewSpriteImage();
        // Initialize the grid
        drawGrid();
    </script>
</body>

</html>